# M2 用户管理服务 - 与 M1 服务集成

## 文档信息

**服务名称**: 用户管理服务 (user-service)  
**依赖服务**: M1 认证授权服务 (auth-service)  
**版本**: v1.0

---

## 目录

1. [集成概述](#集成概述)
2. [服务间通信](#服务间通信)
3. [用户创建流程](#用户创建流程)
4. [认证集成](#认证集成)
5. [错误处理](#错误处理)
6. [测试方案](#测试方案)

---

## 集成概述

### M1 与 M2 的职责边界

| 维度         | M1 认证授权服务              | M2 用户管理服务                    |
| ------------ | ---------------------------- | ---------------------------------- |
| **数据库表** | `users_auth`                 | `users_profile`, `user_statistics` |
| **存储内容** | 用户名、密码哈希、角色、状态 | 昵称、头像、简介、统计数据         |
| **核心功能** | 登录、权限验证、密码管理     | 用户资料管理、活动统计             |
| **依赖关系** | 独立服务                     | 依赖 M1                            |

### 关联方式

```
M1: users_auth                M2: users_profile
┌─────────────────┐          ┌──────────────────┐
│ id (PK) = 1     │ ────────→│ user_id (PK,FK)=1│
│ username: alice │          │ nickname: Alice  │
│ password_hash   │          │ avatar_url       │
│ status: active  │          │ bio              │
└─────────────────┘          └──────────────────┘
```

**关键点**:

- M1 创建用户时生成 `user_id`
- M2 使用相同的 `user_id` 作为主键
- 通过 `user_id` 关联两个服务的数据

---

## 服务间通信

### 1. HTTP REST API 调用

M2 通过 HTTP 调用 M1 的 API 接口。

#### Python requests 库

```python
# apps/core/http_client.py
import requests
from django.conf import settings
import logging

logger = logging.getLogger(__name__)

class AuthServiceClient:
    """M1 认证服务客户端"""

    BASE_URL = settings.AUTH_SERVICE_URL  # http://auth-service:8001

    @classmethod
    def create_user(cls, username: str, password: str, role: str = 'user') -> dict:
        """调用 M1 创建用户账号"""
        url = f"{cls.BASE_URL}/api/auth/users"
        payload = {
            'username': username,
            'password': password,
            'role': role
        }

        try:
            response = requests.post(url, json=payload, timeout=5)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.Timeout:
            logger.error("调用 M1 创建用户超时")
            raise Exception("认证服务超时")
        except requests.exceptions.HTTPError as e:
            logger.error(f"调用 M1 创建用户失败: {e.response.text}")
            raise Exception(f"创建认证账号失败: {e.response.text}")
        except Exception as e:
            logger.error(f"调用 M1 异常: {str(e)}")
            raise

    @classmethod
    def verify_token(cls, token: str) -> dict:
        """验证 JWT Token"""
        url = f"{cls.BASE_URL}/api/auth/verify"
        payload = {'token': token}

        try:
            response = requests.post(url, json=payload, timeout=2)
            if response.status_code == 200:
                return response.json()['data']
            else:
                return None
        except Exception as e:
            logger.error(f"验证 Token 失败: {str(e)}")
            return None

    @classmethod
    def get_user_auth_info(cls, user_id: int) -> dict:
        """获取用户认证信息（用户名、角色、状态）"""
        url = f"{cls.BASE_URL}/api/auth/users/{user_id}"

        try:
            response = requests.get(url, timeout=3)
            response.raise_for_status()
            return response.json()['data']
        except Exception as e:
            logger.error(f"获取用户认证信息失败: {str(e)}")
            return None
```

### 2. 配置 M1 服务地址

```python
# config/settings.py

# M1 认证服务地址
AUTH_SERVICE_URL = os.getenv('AUTH_SERVICE_URL', 'http://localhost:8001')

# 服务间通信超时配置
SERVICE_TIMEOUT = {
    'connect': 2,  # 连接超时
    'read': 5,     # 读取超时
}
```

### 3. Docker Compose 网络配置

```yaml
# docker-compose.yml
version: "3.8"

services:
  auth-service:
    image: auth-service:latest
    container_name: auth-service
    ports:
      - "8001:8001"
    networks:
      - open436-network

  user-service:
    image: user-service:latest
    container_name: user-service
    ports:
      - "8002:8002"
    environment:
      - AUTH_SERVICE_URL=http://auth-service:8001
    depends_on:
      - auth-service
    networks:
      - open436-network

networks:
  open436-network:
    driver: bridge
```

---

## 用户创建流程

### 完整流程图

```
管理员                M2 用户服务           M1 认证服务
  │                      │                      │
  │  POST /api/admin/users                     │
  ├─────────────────────>│                      │
  │                      │                      │
  │                      │  POST /api/auth/users
  │                      ├─────────────────────>│
  │                      │                      │
  │                      │    创建 users_auth   │
  │                      │    生成 user_id      │
  │                      │                      │
  │                      │  返回 {user_id: 1}   │
  │                      │<─────────────────────┤
  │                      │                      │
  │          创建 users_profile(user_id=1)      │
  │          创建 user_statistics(user_id=1)    │
  │                      │                      │
  │  返回用户完整信息     │                      │
  │<─────────────────────┤                      │
  │                      │                      │
```

### Django 实现

```python
# apps/users/services.py
from django.db import transaction
from .models import UserProfile, UserStatistics
from apps.core.http_client import AuthServiceClient
import logging

logger = logging.getLogger(__name__)

class UserCreateService:
    """用户创建服务"""

    @classmethod
    @transaction.atomic
    def create_user(cls, username: str, password: str, role: str,
                    nickname: str, avatar_url: str = '', bio: str = '') -> UserProfile:
        """
        创建完整的用户账号（认证账号 + 用户资料）

        Args:
            username: 用户名（M1）
            password: 密码（M1）
            role: 用户角色（M1）
            nickname: 昵称（M2）
            avatar_url: 头像 URL（M2）
            bio: 个人简介（M2）

        Returns:
            UserProfile: 用户资料对象

        Raises:
            Exception: 创建失败时抛出异常
        """
        # 1. 调用 M1 创建认证账号
        logger.info(f"开始创建用户: username={username}, role={role}")

        try:
            auth_response = AuthServiceClient.create_user(
                username=username,
                password=password,
                role=role
            )
            user_id = auth_response['data']['user_id']
            logger.info(f"M1 创建认证账号成功，user_id={user_id}")
        except Exception as e:
            logger.error(f"调用 M1 创建账号失败: {str(e)}")
            raise Exception(f"创建认证账号失败: {str(e)}")

        # 2. 创建用户资料
        try:
            profile = UserProfile.objects.create(
                user_id=user_id,
                nickname=nickname,
                avatar_url=avatar_url,
                bio=bio
            )
            logger.info(f"创建用户资料成功，user_id={user_id}")
        except Exception as e:
            logger.error(f"创建用户资料失败: {str(e)}")
            # 如果创建资料失败，需要回滚 M1 的账号（或记录待清理）
            raise Exception(f"创建用户资料失败: {str(e)}")

        # 3. 创建统计记录
        try:
            UserStatistics.objects.create(user_id=profile.user_id)
            logger.info(f"创建用户统计记录成功，user_id={user_id}")
        except Exception as e:
            logger.error(f"创建统计记录失败: {str(e)}")
            raise Exception(f"创建统计记录失败: {str(e)}")

        logger.info(f"用户创建完成: user_id={user_id}, username={username}")
        return profile
```

### ViewSet 调用

```python
# apps/users/views.py
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.permissions import IsAdminUser
from .services import UserCreateService
from .serializers import UserProfileDetailSerializer

class AdminUserViewSet(viewsets.ModelViewSet):
    """管理员用户管理 ViewSet"""
    permission_classes = [IsAdminUser]

    def create(self, request):
        """创建用户"""
        # 验证输入
        username = request.data.get('username')
        password = request.data.get('password')
        role = request.data.get('role', 'user')
        nickname = request.data.get('nickname')
        avatar_url = request.data.get('avatar_url', '')
        bio = request.data.get('bio', '')

        if not all([username, password, nickname]):
            return Response({
                'code': 400,
                'message': '缺少必填参数'
            }, status=status.HTTP_400_BAD_REQUEST)

        # 调用服务创建用户
        try:
            profile = UserCreateService.create_user(
                username=username,
                password=password,
                role=role,
                nickname=nickname,
                avatar_url=avatar_url,
                bio=bio
            )

            serializer = UserProfileDetailSerializer(profile)
            return Response({
                'code': 201,
                'message': '用户创建成功',
                'data': serializer.data,
                'timestamp': int(timezone.now().timestamp() * 1000)
            }, status=status.HTTP_201_CREATED)

        except Exception as e:
            return Response({
                'code': 500,
                'message': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
```

---

## 认证集成

### JWT Token 验证

M2 需要验证用户的 JWT Token 来识别用户身份。

#### 自定义认证类

```python
# apps/core/authentication.py
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed
from apps.core.http_client import AuthServiceClient
import logging

logger = logging.getLogger(__name__)

class JWTAuthentication(BaseAuthentication):
    """JWT 认证（调用 M1 验证）"""

    def authenticate(self, request):
        """验证请求中的 JWT Token"""
        auth_header = request.META.get('HTTP_AUTHORIZATION', '')

        if not auth_header:
            return None

        if not auth_header.startswith('Bearer '):
            raise AuthenticationFailed('Invalid authorization header')

        token = auth_header.split(' ')[1]

        # 调用 M1 验证 Token
        try:
            user_data = AuthServiceClient.verify_token(token)
            if not user_data:
                raise AuthenticationFailed('Invalid or expired token')

            logger.debug(f"Token 验证成功: user_id={user_data.get('user_id')}")
            return (user_data, token)

        except Exception as e:
            logger.error(f"Token 验证失败: {str(e)}")
            raise AuthenticationFailed(f'Token verification failed: {str(e)}')

    def authenticate_header(self, request):
        return 'Bearer'
```

#### 在 Django 中配置

```python
# config/settings.py
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'apps.core.authentication.JWTAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticatedOrReadOnly',
    ],
}
```

#### 在 ViewSet 中使用

```python
# apps/users/views.py
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated
from apps.core.permissions import IsOwnerOrAdmin

class UserViewSet(viewsets.ModelViewSet):
    """用户资料 ViewSet"""
    permission_classes = [IsAuthenticated]  # 需要登录

    def get_permissions(self):
        """根据操作设置权限"""
        if self.action in ['update', 'partial_update']:
            return [IsOwnerOrAdmin()]
        return super().get_permissions()

    def update(self, request, user_id=None):
        """更新用户资料"""
        # request.user 包含从 JWT 解析的用户信息
        current_user_id = request.user.get('user_id')
        is_admin = request.user.get('is_admin', False)

        # 权限检查
        if current_user_id != user_id and not is_admin:
            return Response({
                'code': 403,
                'message': '权限不足'
            }, status=403)

        # 更新逻辑...
```

---

## 错误处理

### 1. M1 服务不可用

```python
# apps/core/http_client.py
class AuthServiceClient:
    @classmethod
    def create_user(cls, username: str, password: str, role: str = 'user') -> dict:
        try:
            response = requests.post(url, json=payload, timeout=5)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.ConnectionError:
            # M1 服务不可用
            logger.error("无法连接到 M1 认证服务")
            raise Exception("认证服务不可用，请稍后重试")
        except requests.exceptions.Timeout:
            # 请求超时
            logger.error("调用 M1 认证服务超时")
            raise Exception("认证服务响应超时")
        except requests.exceptions.HTTPError as e:
            # HTTP 错误（400, 500等）
            logger.error(f"M1 服务返回错误: {e.response.status_code} - {e.response.text}")
            raise Exception(f"认证服务错误: {e.response.text}")
```

### 2. 用户名已存在

```python
# apps/users/services.py
class UserCreateService:
    @classmethod
    def create_user(cls, username: str, **kwargs):
        try:
            auth_response = AuthServiceClient.create_user(username, password, role)
            user_id = auth_response['data']['user_id']
        except Exception as e:
            error_msg = str(e)
            if '用户名已存在' in error_msg or 'already exists' in error_msg:
                raise Exception(f"用户名 '{username}' 已被使用")
            else:
                raise Exception(f"创建认证账号失败: {error_msg}")
```

### 3. 事务回滚问题

**问题**: M1 创建成功，但 M2 创建失败，导致数据不一致。

**解决方案 1**: 补偿事务

```python
# apps/users/services.py
class UserCreateService:
    @classmethod
    def create_user(cls, username: str, **kwargs):
        user_id = None
        try:
            # 1. 创建 M1 账号
            auth_response = AuthServiceClient.create_user(username, password, role)
            user_id = auth_response['data']['user_id']

            # 2. 创建 M2 资料
            profile = UserProfile.objects.create(user_id=user_id, **kwargs)
            UserStatistics.objects.create(user_id=user_id)

            return profile
        except Exception as e:
            # 如果 M2 创建失败，需要删除 M1 的账号
            if user_id:
                try:
                    AuthServiceClient.delete_user(user_id)
                    logger.info(f"回滚：已删除 M1 账号 user_id={user_id}")
                except Exception as rollback_error:
                    logger.error(f"回滚失败: {str(rollback_error)}")
                    # 记录到失败队列，人工处理
            raise
```

**解决方案 2**: 最终一致性（推荐）

```python
# 记录创建失败的 user_id，定时任务检查并补齐
class IncompleteUser(models.Model):
    """不完整的用户记录"""
    user_id = models.IntegerField(primary_key=True)
    username = models.CharField(max_length=20)
    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=20, default='pending')  # pending, completed, failed

# 定时任务
@periodic_task(run_every=timedelta(minutes=5))
def check_incomplete_users():
    """检查并补全不完整的用户"""
    incomplete = IncompleteUser.objects.filter(status='pending')
    for record in incomplete:
        try:
            # 尝试创建资料
            if not UserProfile.objects.filter(user_id=record.user_id).exists():
                UserProfile.objects.create(user_id=record.user_id, nickname=record.username)
                UserStatistics.objects.create(user_id=record.user_id)
            record.status = 'completed'
            record.save()
        except Exception as e:
            logger.error(f"补全用户失败: {record.user_id} - {str(e)}")
```

---

## 测试方案

### 1. Mock M1 服务（单元测试）

```python
# tests/test_user_create.py
from unittest.mock import patch, Mock
from django.test import TestCase
from apps.users.services import UserCreateService

class UserCreateServiceTest(TestCase):
    """用户创建服务测试"""

    @patch('apps.core.http_client.AuthServiceClient.create_user')
    def test_create_user_success(self, mock_create_user):
        """测试创建用户成功"""
        # Mock M1 返回结果
        mock_create_user.return_value = {
            'code': 201,
            'data': {'user_id': 1}
        }

        # 调用创建服务
        profile = UserCreateService.create_user(
            username='alice',
            password='password123',
            role='user',
            nickname='Alice'
        )

        # 验证结果
        self.assertEqual(profile.user_id, 1)
        self.assertEqual(profile.nickname, 'Alice')
        mock_create_user.assert_called_once_with(
            username='alice',
            password='password123',
            role='user'
        )

    @patch('apps.core.http_client.AuthServiceClient.create_user')
    def test_create_user_m1_failed(self, mock_create_user):
        """测试 M1 创建失败"""
        # Mock M1 抛出异常
        mock_create_user.side_effect = Exception('用户名已存在')

        # 验证抛出异常
        with self.assertRaises(Exception) as context:
            UserCreateService.create_user(
                username='alice',
                password='password123',
                role='user',
                nickname='Alice'
            )

        self.assertIn('用户名已存在', str(context.exception))
```

### 2. 集成测试（Docker Compose）

```bash
# 启动测试环境
docker-compose -f docker-compose.test.yml up -d

# 运行集成测试
docker exec user-service python manage.py test tests.integration
```

### 3. 健康检查接口

```python
# apps/core/views.py
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from apps.core.http_client import AuthServiceClient

@api_view(['GET'])
@permission_classes([AllowAny])
def health_check(request):
    """健康检查接口"""
    checks = {
        'database': check_database(),
        'm1_service': check_m1_service(),
    }

    all_healthy = all(checks.values())
    status_code = 200 if all_healthy else 503

    return Response({
        'status': 'healthy' if all_healthy else 'unhealthy',
        'checks': checks
    }, status=status_code)

def check_m1_service():
    """检查 M1 服务可用性"""
    try:
        response = requests.get(
            f"{settings.AUTH_SERVICE_URL}/health",
            timeout=2
        )
        return response.status_code == 200
    except:
        return False
```

---

**文档版本**: v1.0  
**创建日期**: 2025-10-27  
**最后更新**: 2025-10-27

# 服务间通信规范

## 文档信息

**文档版本**: v1.0  
**创建日期**: 2025-10-23  
**文档类型**: 技术设计文档（TDD）  
**适用范围**: 后端开发团队

---

## 目录

1. [通信方式概述](#通信方式概述)
2. [如何调用其他服务](#如何调用其他服务)
3. [鉴权模块集成](#鉴权模块集成)
4. [服务间调用示例](#服务间调用示例)
5. [错误处理规范](#错误处理规范)
6. [超时与重试策略](#超时与重试策略)

---

## 通信方式概述

### 1.1 通信架构

```
服务 A (调用方)
    ↓
查询 Consul 获取服务 B 地址
    ↓
直接调用服务 B（HTTP/REST）
    ↓
服务 B (被调用方)
```

**关键原则**：
- ✅ 使用 **Consul** 进行服务注册与发现
- ✅ 服务间使用 HTTP/REST API 直接通信
- ✅ 携带认证 Token（Sa-Token）进行鉴权
- ✅ 通过 Consul 健康检查保证服务可用性
- ❌ 禁止直接访问其他服务的数据库
- ❌ 禁止硬编码服务地址

### 1.2 Consul 服务发现优势

| 优势 | 说明 |
|------|------|
| **自动服务发现** | 无需硬编码地址，动态获取服务实例 |
| **健康检查** | 自动剔除不健康的服务实例 |
| **负载均衡** | 客户端可实现多种负载均衡策略 |
| **高可用** | Consul 集群保证服务注册中心可用 |
| **配置中心** | 支持 KV 存储作为配置管理 |
| **多数据中心** | 支持跨数据中心的服务发现 |

### 1.3 通信架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      Consul Cluster                          │
│                   (服务注册与发现中心)                         │
└────────────────────────┬────────────────────────────────────┘
                         │
         ┌───────────────┼───────────────┬──────────────┐
         │               │               │              │
    ┌────▼────┐    ┌────▼────┐    ┌────▼────┐    ┌───▼────┐
    │   S1    │───▶│   S2    │───▶│   S3    │───▶│   S4   │
    │  认证   │    │  用户   │    │  内容   │    │  互动  │
    │ (Sa-Token)   │  管理   │    │  管理   │    │  评论  │
    └─────────┘    └─────────┘    └─────────┘    └────────┘
         ▲              ▲              ▲              ▲
         │              │              │              │
         └──────────────┴──────────────┴──────────────┘
              所有服务注册到 Consul 并定期健康检查
```

**工作流程**：
1. 所有服务启动时向 Consul 注册自己
2. Consul 定期对服务进行健康检查
3. 服务 A 需要调用服务 B 时，先从 Consul 查询服务 B 的健康实例列表
4. 服务 A 选择一个实例（负载均衡）发起 HTTP 请求
5. 请求携带 Sa-Token 进行身份认证

---

## 如何调用其他服务

### 2.1 配置 Consul 连接

**环境变量配置**：

```bash
# .env
CONSUL_HOST=localhost
CONSUL_PORT=8500
SERVICE_NAME=auth-service
SERVICE_PORT=8001
SERVICE_TOKEN_SECRET=your-service-token-secret
```

### 2.2 HTTP 客户端封装（集成 Consul）

#### Node.js 示例

```javascript
// utils/serviceClient.js
const axios = require('axios');
const Consul = require('consul');

class ServiceClient {
  constructor() {
    // 初始化 Consul 客户端
    this.consul = new Consul({
      host: process.env.CONSUL_HOST || 'localhost',
      port: process.env.CONSUL_PORT || 8500,
      promisify: true
    });
    
    this.serviceName = process.env.SERVICE_NAME;
    this.serviceCache = new Map(); // 缓存服务实例列表
    this.cacheTTL = 30000; // 缓存30秒
  }

  // 从 Consul 获取服务地址
  async getServiceUrl(serviceName) {
    // 检查缓存
    const cached = this.serviceCache.get(serviceName);
    if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
      return this.selectInstance(cached.instances);
    }

    try {
      // 从 Consul 查询健康的服务实例
      const services = await this.consul.health.service({
        service: serviceName,
        passing: true  // 只获取健康检查通过的实例
      });

      if (!services || services.length === 0) {
        throw new Error(`Service ${serviceName} not available`);
      }

      // 缓存服务实例列表
      this.serviceCache.set(serviceName, {
        instances: services,
        timestamp: Date.now()
      });

      return this.selectInstance(services);
    } catch (error) {
      throw new Error(`Failed to discover service ${serviceName}: ${error.message}`);
    }
  }

  // 负载均衡：简单轮询
  selectInstance(services) {
    const service = services[Math.floor(Math.random() * services.length)];
    const { Address, Port } = service.Service;
    return `http://${Address}:${Port}`;
  }

  // 通用请求方法
  async request(serviceName, method, path, data = null, headers = {}, token = null) {
    try {
      // 从 Consul 获取服务地址
      const baseUrl = await this.getServiceUrl(serviceName);
      
      const response = await axios({
        method,
        url: `${baseUrl}${path}`,
        data,
        headers: {
          'Authorization': token ? `Bearer ${token}` : undefined,
          'X-Service-Name': this.serviceName,
          'Content-Type': 'application/json',
          ...headers
        },
        timeout: 5000
      });
      
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  // GET 请求
  async get(serviceName, path, token = null, headers = {}) {
    return this.request(serviceName, 'GET', path, null, headers, token);
  }

  // POST 请求
  async post(serviceName, path, data, token = null, headers = {}) {
    return this.request(serviceName, 'POST', path, data, headers, token);
  }

  // PUT 请求
  async put(serviceName, path, data, token = null, headers = {}) {
    return this.request(serviceName, 'PUT', path, data, headers, token);
  }

  // DELETE 请求
  async delete(serviceName, path, token = null, headers = {}) {
    return this.request(serviceName, 'DELETE', path, null, headers, token);
  }

  // 错误处理
  handleError(error) {
    if (error.response) {
      // 服务返回错误
      const err = new Error(error.response.data.message || 'Service error');
      err.status = error.response.status;
      err.data = error.response.data;
      throw err;
    } else if (error.request) {
      // 请求超时或网络错误
      const err = new Error('Service unavailable');
      err.status = 503;
      throw err;
    } else {
      // 其他错误
      const err = new Error(error.message || 'Internal error');
      err.status = 500;
      throw err;
    }
  }
}

module.exports = new ServiceClient();
```

**使用示例**：

```javascript
const serviceClient = require('./utils/serviceClient');

// 调用用户服务
const user = await serviceClient.get('user-service', '/api/users/123', userToken);

// 调用认证服务验证 Token
const authResult = await serviceClient.post(
  'auth-service',
  '/api/auth/verify',
  { token: userToken }
);
```

#### Java 示例（使用 Spring Cloud Consul）

**Maven 依赖**：

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-consul-discovery</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

**配置文件** (application.yml)：

```yaml
spring:
  cloud:
    consul:
      host: ${CONSUL_HOST:localhost}
      port: ${CONSUL_PORT:8500}
      discovery:
        enabled: true
        service-name: ${spring.application.name}
        health-check-path: /actuator/health
        health-check-interval: 10s
```

**服务客户端实现**：

```java
// ServiceClient.java
package com.open436.common.client;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.http.*;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.client.RestClientException;

import java.util.List;
import java.util.Random;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class ServiceClient {
    
    @Autowired
    private DiscoveryClient discoveryClient;
    
    @Autowired
    private RestTemplate restTemplate;
    
    // 服务实例缓存
    private final Map<String, CachedInstances> serviceCache = new ConcurrentHashMap<>();
    private static final long CACHE_TTL = 30000; // 30秒缓存
    
    /**
     * 从 Consul 获取服务地址
     */
    private String getServiceUrl(String serviceName) {
        // 检查缓存
        CachedInstances cached = serviceCache.get(serviceName);
        if (cached != null && System.currentTimeMillis() - cached.timestamp < CACHE_TTL) {
            return selectInstance(cached.instances);
        }
        
        // 从 Consul 获取服务实例
        List<ServiceInstance> instances = discoveryClient.getInstances(serviceName);
        
        if (instances == null || instances.isEmpty()) {
            throw new ServiceUnavailableException("Service " + serviceName + " not available");
        }
        
        // 缓存实例列表
        serviceCache.put(serviceName, new CachedInstances(instances));
        
        return selectInstance(instances);
    }
    
    /**
     * 负载均衡：简单随机
     */
    private String selectInstance(List<ServiceInstance> instances) {
        ServiceInstance instance = instances.get(new Random().nextInt(instances.size()));
        return instance.getUri().toString();
    }
    
    /**
     * GET 请求
     */
    public <T> T get(String serviceName, String path, String token, Class<T> responseType) {
        String url = getServiceUrl(serviceName) + path;
        HttpHeaders headers = createHeaders(token);
        HttpEntity<Void> entity = new HttpEntity<>(headers);
        
        try {
            ResponseEntity<T> response = restTemplate.exchange(
                url,
                HttpMethod.GET,
                entity,
                responseType
            );
            return response.getBody();
        } catch (RestClientException e) {
            throw new ServiceCallException("Failed to call service: " + serviceName, e);
        }
    }
    
    /**
     * POST 请求
     */
    public <T, R> R post(String serviceName, String path, T body, String token, Class<R> responseType) {
        String url = getServiceUrl(serviceName) + path;
        HttpHeaders headers = createHeaders(token);
        HttpEntity<T> entity = new HttpEntity<>(body, headers);
        
        try {
            ResponseEntity<R> response = restTemplate.exchange(
                url,
                HttpMethod.POST,
                entity,
                responseType
            );
            return response.getBody();
        } catch (RestClientException e) {
            throw new ServiceCallException("Failed to call service: " + serviceName, e);
        }
    }
    
    /**
     * PUT 请求
     */
    public <T, R> R put(String serviceName, String path, T body, String token, Class<R> responseType) {
        String url = getServiceUrl(serviceName) + path;
        HttpHeaders headers = createHeaders(token);
        HttpEntity<T> entity = new HttpEntity<>(body, headers);
        
        try {
            ResponseEntity<R> response = restTemplate.exchange(
                url,
                HttpMethod.PUT,
                entity,
                responseType
            );
            return response.getBody();
        } catch (RestClientException e) {
            throw new ServiceCallException("Failed to call service: " + serviceName, e);
        }
    }
    
    /**
     * DELETE 请求
     */
    public <T> T delete(String serviceName, String path, String token, Class<T> responseType) {
        String url = getServiceUrl(serviceName) + path;
        HttpHeaders headers = createHeaders(token);
        HttpEntity<Void> entity = new HttpEntity<>(headers);
        
        try {
            ResponseEntity<T> response = restTemplate.exchange(
                url,
                HttpMethod.DELETE,
                entity,
                responseType
            );
            return response.getBody();
        } catch (RestClientException e) {
            throw new ServiceCallException("Failed to call service: " + serviceName, e);
        }
    }
    
    /**
     * 创建请求头
     */
    private HttpHeaders createHeaders(String token) {
        HttpHeaders headers = new HttpHeaders();
        if (token != null && !token.isEmpty()) {
            headers.set("Authorization", "Bearer " + token);
        }
        headers.setContentType(MediaType.APPLICATION_JSON);
        return headers;
    }
    
    /**
     * 缓存的服务实例
     */
    private static class CachedInstances {
        final List<ServiceInstance> instances;
        final long timestamp;
        
        CachedInstances(List<ServiceInstance> instances) {
            this.instances = instances;
            this.timestamp = System.currentTimeMillis();
        }
    }
}
```

**使用示例**：

```java
@Service
public class UserService {
    
    @Autowired
    private ServiceClient serviceClient;
    
    public UserDTO getUserById(Long userId, String token) {
        return serviceClient.get(
            "user-service",
            "/api/users/" + userId,
            token,
            UserDTO.class
        );
    }
    
    public AuthResponse verifyToken(String token) {
        return serviceClient.post(
            "auth-service",
            "/api/auth/verify",
            Map.of("token", token),
            null,
            AuthResponse.class
        );
    }
}
```

#### Python 示例（使用 python-consul）

**依赖安装**：

```bash
pip install python-consul requests
```

**服务客户端实现**：

```python
# service_client.py
import os
import consul
import requests
import random
import time
from typing import Optional, Dict, Any, List
from datetime import datetime, timedelta

class ServiceClient:
    def __init__(self):
        # 初始化 Consul 客户端
        self.consul_client = consul.Consul(
            host=os.getenv('CONSUL_HOST', 'localhost'),
            port=int(os.getenv('CONSUL_PORT', 8500))
        )
        
        self.service_name = os.getenv('SERVICE_NAME')
        self.timeout = 5
        
        # 服务实例缓存
        self.service_cache = {}
        self.cache_ttl = 30  # 30秒缓存
    
    def get_service_url(self, service_name: str) -> str:
        """从 Consul 获取服务地址"""
        # 检查缓存
        if service_name in self.service_cache:
            cached = self.service_cache[service_name]
            if time.time() - cached['timestamp'] < self.cache_ttl:
                return self._select_instance(cached['instances'])
        
        try:
            # 从 Consul 查询健康的服务实例
            _, services = self.consul_client.health.service(
                service_name,
                passing=True  # 只获取健康检查通过的实例
            )
            
            if not services:
                raise Exception(f"Service {service_name} not available")
            
            # 缓存服务实例列表
            self.service_cache[service_name] = {
                'instances': services,
                'timestamp': time.time()
            }
            
            return self._select_instance(services)
        except Exception as e:
            raise Exception(f"Failed to discover service {service_name}: {str(e)}")
    
    def _select_instance(self, services: List[Dict]) -> str:
        """负载均衡：简单随机"""
        service = random.choice(services)
        address = service['Service']['Address']
        port = service['Service']['Port']
        return f"http://{address}:{port}"
    
    def _create_headers(self, token: Optional[str] = None, extra_headers: Optional[Dict] = None) -> Dict:
        """创建请求头"""
        headers = {
            'Content-Type': 'application/json'
        }
        
        if token:
            headers['Authorization'] = f'Bearer {token}'
        
        if extra_headers:
            headers.update(extra_headers)
        
        return headers
    
    def get(self, service_name: str, path: str, token: Optional[str] = None, 
            headers: Optional[Dict] = None) -> Any:
        """GET 请求"""
        url = self.get_service_url(service_name) + path
        
        try:
            response = requests.get(
                url,
                headers=self._create_headers(token, headers),
                timeout=self.timeout
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            raise Exception(f"Failed to call service {service_name}: {str(e)}")
    
    def post(self, service_name: str, path: str, data: Dict, 
             token: Optional[str] = None, headers: Optional[Dict] = None) -> Any:
        """POST 请求"""
        url = self.get_service_url(service_name) + path
        
        try:
            response = requests.post(
                url,
                json=data,
                headers=self._create_headers(token, headers),
                timeout=self.timeout
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            raise Exception(f"Failed to call service {service_name}: {str(e)}")
    
    def put(self, service_name: str, path: str, data: Dict, 
            token: Optional[str] = None, headers: Optional[Dict] = None) -> Any:
        """PUT 请求"""
        url = self.get_service_url(service_name) + path
        
        try:
            response = requests.put(
                url,
                json=data,
                headers=self._create_headers(token, headers),
                timeout=self.timeout
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            raise Exception(f"Failed to call service {service_name}: {str(e)}")
    
    def delete(self, service_name: str, path: str, token: Optional[str] = None, 
               headers: Optional[Dict] = None) -> Any:
        """DELETE 请求"""
        url = self.get_service_url(service_name) + path
        
        try:
            response = requests.delete(
                url,
                headers=self._create_headers(token, headers),
                timeout=self.timeout
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            raise Exception(f"Failed to call service {service_name}: {str(e)}")

# 单例
service_client = ServiceClient()
```

**使用示例**：

```python
from service_client import service_client

# 调用用户服务
user = service_client.get('user-service', '/api/users/123', token=user_token)

# 调用认证服务验证 Token
auth_result = service_client.post(
    'auth-service',
    '/api/auth/verify',
    {'token': user_token}
)
```

---

## 鉴权模块集成（Sa-Token）

### 3.1 认证方案说明

**技术方案**：Sa-Token 自动续签

| 特性 | 说明 |
|------|------|
| **Token 类型** | 单 Token（自动续签） |
| **Token 格式** | UUID（如：`satoken:satoken:xyz123...`） |
| **有效期** | 30 天（自动续签） |
| **存储位置** | Redis（Session + Token） |
| **续签机制** | 访问时自动延长有效期 |
| **登出处理** | 清除 Session 和 Token |

**对比传统 JWT**：

| 特性 | Sa-Token | JWT 双 Token |
|------|----------|-------------|
| Token 数量 | 1 个 | 2 个（Access + Refresh） |
| 手动刷新 | ❌ 自动续签 | ✅ 需要手动刷新 |
| 代码复杂度 | 低 | 高 |
| 用户体验 | 无感知 | 需处理刷新逻辑 |
| 安全性 | 高（可随时撤销） | 中（无法撤销JWT） |

### 3.2 如何使用认证服务（S1）

#### 场景 1：验证用户 Token

**方式1：调用认证服务验证（推荐）**

```javascript
// user-service/middleware/auth.js
const serviceClient = require('../utils/serviceClient');

async function authenticateUser(req, res, next) {
  try {
    // 从请求头获取 Sa-Token
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }
    
    // 调用认证服务验证 Token
    const result = await serviceClient.post(
      'auth-service',
      '/api/auth/verify',
      { token }
    );
    
    if (!result.valid) {
      return res.status(401).json({ error: 'Invalid token' });
    }
    
    // 将用户信息附加到请求对象
    req.user = {
      id: result.userId,
      username: result.username,
      role: result.role
    };
    
    next();
  } catch (error) {
    console.error('Authentication error:', error);
    res.status(500).json({ error: 'Authentication failed' });
  }
}

module.exports = authenticateUser;
```

**方式2：直接从 Kong 注入的 Header 获取（性能更好）**

如果在 Kong 网关配置了 JWT 验证插件，Kong 会将用户信息注入到 Header：

```javascript
// Kong 已经验证过 Token，直接读取注入的 Header
function getUserFromKongHeaders(req) {
  return {
    id: req.headers['x-consumer-custom-id'],
    username: req.headers['x-consumer-username'],
    role: req.headers['x-jwt-claim-role']  // 从 Token Payload 中提取
  };
}

// 使用
app.get('/api/users/:id', (req, res) => {
  const currentUser = getUserFromKongHeaders(req);
  
  // 权限检查
  if (currentUser.id !== req.params.id && currentUser.role !== 'admin') {
    return res.status(403).json({ error: 'Forbidden' });
  }
  
  // 业务逻辑...
});
```

**Java (Spring Boot) 示例**：

```java
// AuthenticationFilter.java
@Component
public class AuthenticationFilter extends OncePerRequestFilter {
    
    @Autowired
    private ServiceClient serviceClient;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response, 
                                    FilterChain filterChain) throws ServletException, IOException {
        String token = extractToken(request);
        
        if (token == null) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }
        
        try {
            // 调用认证服务验证 Token
            Map<String, Object> requestBody = Map.of("token", token);
            AuthVerifyResponse authResult = serviceClient.post(
                "auth-service",
                "/api/auth/verify",
                requestBody,
                null,
                AuthVerifyResponse.class
            );
            
            if (!authResult.isValid()) {
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                return;
            }
            
            // 将用户信息存入请求属性
            request.setAttribute("userId", authResult.getUserId());
            request.setAttribute("username", authResult.getUsername());
            request.setAttribute("role", authResult.getRole());
            
            filterChain.doFilter(request, response);
        } catch (Exception e) {
            logger.error("Authentication failed", e);
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        }
    }
    
    private String extractToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

**Python (FastAPI) 示例**：

```python
# middleware/auth.py
from fastapi import Request, HTTPException, status
from service_client import service_client

async def authenticate_user(request: Request):
    """验证用户 Token"""
    authorization = request.headers.get('Authorization')
    
    if not authorization:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail='No token provided'
        )
    
    token = authorization.replace('Bearer ', '')
    
    try:
        # 调用认证服务验证 Token
        result = service_client.post(
            'auth-service',
            '/api/auth/verify',
            {'token': token}
        )
        
        if not result.get('valid'):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail='Invalid token'
            )
        
        # 返回用户信息
        return {
            'id': result['userId'],
            'username': result['username'],
            'role': result['role']
        }
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail='Authentication failed'
        )

# 使用依赖注入
from fastapi import Depends

@app.get("/api/users/{user_id}")
async def get_user(user_id: int, current_user: dict = Depends(authenticate_user)):
    # 权限检查
    if current_user['id'] != user_id and current_user['role'] != 'admin':
        raise HTTPException(status_code=403, detail='Forbidden')
    
    # 业务逻辑...
    return {"user_id": user_id}
```

#### 场景 2：检查用户权限

```javascript
// 调用认证服务检查权限
async function checkPermission(userId, permission, token) {
  const result = await serviceClient.get(
    'auth-service',
    `/api/auth/users/${userId}/permissions`,
    token
  );
  
  return result.permissions.some(p => p.code === permission);
}

// 使用
app.delete('/api/posts/:id', async (req, res) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  const user = req.user;  // 从认证中间件获取
  const post = await getPost(req.params.id);
  
  // 检查是否有删除权限
  const canDelete = post.authorId === user.id || 
                    await checkPermission(user.id, 'delete_any_post', token);
  
  if (!canDelete) {
    return res.status(403).json({ error: 'No permission' });
  }
  
  // 删除帖子...
});
```

#### 场景 3：创建用户（管理员）

```javascript
// admin-service 调用 auth-service 创建用户
app.post('/api/admin/users', async (req, res) => {
  const { username, password, role } = req.body;
  const token = req.headers.authorization?.replace('Bearer ', '');
  
  try {
    // 1. 调用认证服务创建认证账号
    const authResult = await serviceClient.post(
      'auth-service',
      '/api/auth/users',
      { username, password, role },
      token
    );
    
    // 2. 调用用户服务创建用户资料
    const userResult = await serviceClient.post(
      'user-service',
      '/api/users',
      {
        userId: authResult.userId,
        nickname: username,
        avatar: '/default-avatar.png'
      },
      token
    );
    
    res.json({
      userId: authResult.userId,
      username: authResult.username,
      role: authResult.role
    });
  } catch (error) {
    console.error('Failed to create user:', error);
    res.status(500).json({ error: 'Failed to create user' });
  }
});
```

### 3.3 Kong 网关集成 Sa-Token

虽然使用 Consul 进行服务发现，Kong 仍然作为 API 网关处理外部请求。

**Kong 配置说明**：

Sa-Token 生成的是 UUID 格式的 Token，而非标准 JWT。因此：
- **外部请求**（用户→Kong→服务）：Kong 转发 Token，由认证服务验证
- **服务间调用**：直接通过 Consul 发现，不经过 Kong

**Kong 路由配置**：

```yaml
# kong.yml
services:
  - name: auth-service
    url: http://auth-service:8001
    routes:
      - name: auth-route
        paths:
          - /api/auth
        strip_path: false

  - name: user-service
    url: http://user-service:8002
    routes:
      - name: user-route
        paths:
          - /api/users
        strip_path: false
        plugins:
          - name: request-transformer
            config:
              add:
                headers:
                  - X-Gateway: kong
```

**外部请求流程**：

```
客户端（携带 Sa-Token）
    ↓
Kong 网关（转发请求）
    ↓
目标服务（调用认证服务验证 Token）
    ↓
返回响应
```

**不使用 Kong JWT 插件**：

由于 Sa-Token 不是标准 JWT 格式，不使用 Kong 的 JWT 插件。验证逻辑统一在认证服务（S1）中处理。

---

## 服务间调用示例

### 4.1 用户服务调用认证服务（使用 Consul + Sa-Token）

**场景**：获取用户完整信息（资料 + 认证状态）

```javascript
// user-service/controllers/userController.js
const serviceClient = require('../utils/serviceClient');

async function getUserById(req, res) {
  const userId = req.params.id;
  const token = req.headers.authorization?.replace('Bearer ', '');
  
  try {
    // 1. 从本地数据库获取用户资料
    const profile = await db.query(
      'SELECT * FROM users_profile WHERE user_id = $1',
      [userId]
    );
    
    if (!profile) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    // 2. 通过 Consul 发现认证服务并调用（获取认证信息）
    const authInfo = await serviceClient.get(
      'auth-service',  // 服务名（从 Consul 查询）
      `/api/auth/users/${userId}`,
      token  // 传递 Sa-Token
    );
    
    // 3. 合并数据返回
    res.json({
      id: userId,
      username: authInfo.username,
      role: authInfo.role,
      status: authInfo.status,
      nickname: profile.rows[0].nickname,
      avatar: profile.rows[0].avatar,
      bio: profile.rows[0].bio
    });
  } catch (error) {
    console.error('Failed to get user:', error);
    res.status(500).json({ error: 'Failed to get user' });
  }
}
```

**关键改进**：
- ✅ 使用 `'auth-service'` 服务名，而非硬编码 URL
- ✅ ServiceClient 自动从 Consul 获取服务地址
- ✅ 传递 Sa-Token 进行身份认证
- ✅ 自动负载均衡到健康的服务实例

### 4.2 内容服务调用用户服务（使用 Consul + Sa-Token）

**场景**：获取帖子列表时附带作者信息

```python
# post-service/controllers/post_controller.py
from service_client import service_client
from fastapi import Request

async def get_posts(request: Request):
    # 获取用户 Token
    token = request.headers.get('Authorization', '').replace('Bearer ', '')
    
    # 1. 获取帖子列表
    posts = await db.fetch_all("SELECT * FROM posts ORDER BY created_at DESC LIMIT 20")
    
    # 2. 提取作者 ID
    author_ids = [post['author_id'] for post in posts]
    
    if not author_ids:
        return {'posts': []}
    
    # 3. 通过 Consul 发现用户服务并批量调用
    authors = await service_client.post(
        'user-service',  # 服务名（从 Consul 查询）
        '/api/users/batch',
        {'user_ids': author_ids},
        token  # 传递 Sa-Token
    )
    
    # 4. 组装数据
    author_map = {author['id']: author for author in authors.get('users', [])}
    
    result = []
    for post in posts:
        result.append({
            'id': post['id'],
            'title': post['title'],
            'content': post['content'],
            'author': author_map.get(post['author_id'], {
                'id': post['author_id'],
                'nickname': 'Unknown User'
            }),
            'created_at': post['created_at']
        })
    
    return {'posts': result}
```

**关键改进**：
- ✅ 通过服务名 `'user-service'` 调用，Consul 自动解析地址
- ✅ 传递 Sa-Token 进行认证
- ✅ 添加降级处理（作者信息缺失时显示默认值）

### 4.3 互动服务调用内容服务（使用 Consul + Sa-Token）

**场景**：发布回复前验证帖子是否存在

```javascript
// interaction-service/controllers/replyController.js
const serviceClient = require('../utils/serviceClient');

async function createReply(req, res) {
  const { postId, content } = req.body;
  const user = req.user;  // 从认证中间件获取
  const token = req.headers.authorization?.replace('Bearer ', '');
  
  try {
    // 1. 通过 Consul 发现内容服务并验证帖子存在
    const post = await serviceClient.get(
      'post-service',  // 服务名（从 Consul 查询）
      `/api/posts/${postId}`,
      token  // 传递 Sa-Token
    );
    
    if (!post || !post.data) {
      return res.status(404).json({ error: 'Post not found' });
    }
    
    // 2. 创建回复
    const reply = await db.query(
      'INSERT INTO replies (post_id, user_id, content, created_at) VALUES ($1, $2, $3, NOW()) RETURNING *',
      [postId, user.id, content]
    );
    
    // 3. 通知内容服务更新回复计数
    await serviceClient.post(
      'post-service',
      `/api/posts/${postId}/increment-reply-count`,
      {},
      token
    );
    
    res.json({
      code: 200,
      message: '回复成功',
      data: reply.rows[0]
    });
  } catch (error) {
    console.error('Failed to create reply:', error);
    res.status(500).json({ error: 'Failed to create reply' });
  }
}

module.exports = { createReply };
```

**关键改进**：
- ✅ 使用服务名调用，无需硬编码地址
- ✅ Consul 自动负载均衡到健康实例
- ✅ 传递 Sa-Token 保持用户会话上下文
- ✅ 完整的错误处理

---

## 错误处理规范

### 5.1 统一错误响应格式

```json
{
  "code": 404,
  "message": "Resource not found",
  "details": {
    "resource": "post",
    "id": "12345"
  },
  "timestamp": "2025-10-23T10:30:00Z"
}
```

### 5.2 错误码定义

| HTTP 状态码 | 业务错误码 | 说明 | 处理建议 |
|------------|-----------|------|---------|
| 400 | 40001 | 参数错误 | 检查请求参数 |
| 401 | 40101 | 未认证 | 重新登录 |
| 403 | 40301 | 权限不足 | 提示用户无权限 |
| 404 | 40401 | 资源不存在 | 返回空或默认值 |
| 500 | 50001 | 服务内部错误 | 记录日志，返回通用错误 |
| 503 | 50301 | 服务不可用 | 降级处理或重试 |

### 5.3 服务调用错误处理

```javascript
async function callServiceWithFallback(serviceName, path, fallbackValue) {
  try {
    return await serviceClient.get(path);
  } catch (error) {
    // 记录错误日志
    logger.error(`Failed to call ${serviceName}:`, error);
    
    // 返回降级数据
    if (error.status === 503) {
      logger.warn(`${serviceName} unavailable, using fallback`);
      return fallbackValue;
    }
    
    // 其他错误抛出
    throw error;
  }
}

// 使用
const userInfo = await callServiceWithFallback(
  'user-service',
  `/api/users/${userId}`,
  { id: userId, nickname: 'Unknown User' }  // 降级数据
);
```

---

## 超时与重试策略

### 6.1 超时配置

```javascript
// 不同服务的超时时间
const TIMEOUTS = {
  'auth-service': 3000,    // 认证服务 3 秒
  'user-service': 5000,    // 用户服务 5 秒
  'post-service': 5000,    // 内容服务 5 秒
  'file-service': 10000,   // 文件服务 10 秒（上传较慢）
  'search-service': 8000   // 搜索服务 8 秒
};
```

### 6.2 重试策略

```javascript
const axios = require('axios');
const axiosRetry = require('axios-retry');

// 配置重试
axiosRetry(axios, {
  retries: 3,  // 最多重试 3 次
  retryDelay: axiosRetry.exponentialDelay,  // 指数退避
  retryCondition: (error) => {
    // 仅在网络错误或 5xx 错误时重试
    return axiosRetry.isNetworkOrIdempotentRequestError(error) ||
           (error.response && error.response.status >= 500);
  }
});
```

### 6.3 熔断器模式

```javascript
const CircuitBreaker = require('opossum');

// 创建熔断器
const breaker = new CircuitBreaker(serviceClient.get, {
  timeout: 5000,        // 超时时间
  errorThresholdPercentage: 50,  // 错误率超过 50% 时打开熔断器
  resetTimeout: 30000   // 30 秒后尝试恢复
});

// 使用熔断器
breaker.fire('/api/users/123')
  .then(data => console.log(data))
  .catch(err => console.error('Circuit breaker opened:', err));

// 监听事件
breaker.on('open', () => console.log('Circuit breaker opened'));
breaker.on('halfOpen', () => console.log('Circuit breaker half-open'));
breaker.on('close', () => console.log('Circuit breaker closed'));
```

---

## 最佳实践

### 7.1 服务调用清单（基于 Consul + Sa-Token）

| 调用方 | 被调用服务名 | 接口 | 用途 | 认证要求 |
|-------|------------|------|------|---------|
| S2 用户 | `auth-service` | GET /api/auth/users/:id | 获取认证信息 | Sa-Token |
| S3 内容 | `user-service` | POST /api/users/batch | 批量获取作者信息 | Sa-Token |
| S4 互动 | `post-service` | GET /api/posts/:id | 验证帖子存在 | Sa-Token |
| S4 互动 | `post-service` | POST /api/posts/:id/increment-reply-count | 更新回复计数 | Sa-Token |
| S8 管理 | `auth-service` | POST /api/auth/users | 创建用户 | Sa-Token（管理员） |
| 所有服务 | `auth-service` | POST /api/auth/verify | 验证 Sa-Token | 无（公开） |

**调用方式**：
- 通过 ServiceClient 使用服务名调用（如 `'auth-service'`）
- ServiceClient 自动从 Consul 获取服务地址
- 请求携带 Sa-Token 进行身份认证
- Consul 自动负载均衡到健康实例

### 7.2 避免循环依赖

❌ **错误示例**：
```
S2 用户服务 → S3 内容服务 → S2 用户服务（循环）
```

✅ **正确方案**：
- 数据冗余：在 posts 表中存储 author_name
- 异步更新：通过消息队列同步数据
- 聚合服务：由 S8 管理服务统一聚合

### 7.3 缓存策略

```javascript
const Redis = require('ioredis');
const redis = new Redis();

async function getUserWithCache(userId) {
  // 1. 尝试从缓存获取
  const cached = await redis.get(`user:${userId}`);
  if (cached) {
    return JSON.parse(cached);
  }
  
  // 2. 调用服务获取
  const user = await serviceClient.get(`/api/users/${userId}`);
  
  // 3. 写入缓存（30 分钟）
  await redis.setex(`user:${userId}`, 1800, JSON.stringify(user));
  
  return user;
}
```

---

**文档维护**: 后端开发组  
**最后更新**: 2025-10-23

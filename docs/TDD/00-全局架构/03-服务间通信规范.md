# 服务间通信规范

## 文档信息

**文档版本**: v1.0  
**创建日期**: 2025-10-23  
**文档类型**: 技术设计文档（TDD）  
**适用范围**: 后端开发团队

---

## 目录

1. [通信方式概述](#通信方式概述)
2. [如何调用其他服务](#如何调用其他服务)
3. [鉴权模块集成](#鉴权模块集成)
4. [服务间调用示例](#服务间调用示例)
5. [错误处理规范](#错误处理规范)
6. [超时与重试策略](#超时与重试策略)

---

## 通信方式概述

### 1.1 通信架构

```
服务 A (调用方)
    ↓
通过 Kong 内部网关
    ↓
服务 B (被调用方)
```

**关键原则**：
- ✅ 服务间调用**必须通过 Kong 网关**
- ✅ 使用 HTTP/REST API 进行同步通信
- ✅ 携带服务间调用凭证（Service Token）
- ❌ 禁止直接访问其他服务的数据库

### 1.2 为什么通过 Kong

| 优势 | 说明 |
|------|------|
| **统一鉴权** | Kong JWT 插件统一验证 |
| **负载均衡** | 自动分发到多个实例 |
| **监控追踪** | 统一日志和链路追踪 |
| **服务发现** | 无需硬编码服务地址 |

---

## 如何调用其他服务

### 2.1 配置 Kong 内部网关地址

**环境变量配置**：

```bash
# .env
KONG_GATEWAY_URL=http://kong:8000
SERVICE_TOKEN_SECRET=your-service-token-secret
```

### 2.2 HTTP 客户端封装

#### Node.js 示例

```javascript
// utils/serviceClient.js
const axios = require('axios');

class ServiceClient {
  constructor() {
    this.kongUrl = process.env.KONG_GATEWAY_URL || 'http://kong:8000';
    this.serviceToken = this.generateServiceToken();
  }

  // 生成服务间调用 Token
  generateServiceToken() {
    const jwt = require('jsonwebtoken');
    return jwt.sign(
      { 
        service: process.env.SERVICE_NAME,
        type: 'service-to-service'
      },
      process.env.SERVICE_TOKEN_SECRET,
      { expiresIn: '1h' }
    );
  }

  // 通用请求方法
  async request(method, path, data = null, headers = {}) {
    try {
      const response = await axios({
        method,
        url: `${this.kongUrl}${path}`,
        data,
        headers: {
          'Authorization': `Bearer ${this.serviceToken}`,
          'X-Service-Name': process.env.SERVICE_NAME,
          ...headers
        },
        timeout: 5000
      });
      return response.data;
    } catch (error) {
      throw this.handleError(error);
    }
  }

  // GET 请求
  async get(path, headers = {}) {
    return this.request('GET', path, null, headers);
  }

  // POST 请求
  async post(path, data, headers = {}) {
    return this.request('POST', path, data, headers);
  }

  // PUT 请求
  async put(path, data, headers = {}) {
    return this.request('PUT', path, data, headers);
  }

  // DELETE 请求
  async delete(path, headers = {}) {
    return this.request('DELETE', path, null, headers);
  }

  // 错误处理
  handleError(error) {
    if (error.response) {
      // 服务返回错误
      return {
        status: error.response.status,
        message: error.response.data.message || 'Service error',
        data: error.response.data
      };
    } else if (error.request) {
      // 请求超时或网络错误
      return {
        status: 503,
        message: 'Service unavailable',
        error: error.message
      };
    } else {
      // 其他错误
      return {
        status: 500,
        message: 'Internal error',
        error: error.message
      };
    }
  }
}

module.exports = new ServiceClient();
```

#### Java 示例

```java
// ServiceClient.java
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

@Component
public class ServiceClient {
    
    @Value("${kong.gateway.url}")
    private String kongUrl;
    
    @Value("${service.token.secret}")
    private String tokenSecret;
    
    @Value("${service.name}")
    private String serviceName;
    
    private final RestTemplate restTemplate;
    
    public ServiceClient(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }
    
    // 生成服务 Token
    private String generateServiceToken() {
        return Jwts.builder()
            .claim("service", serviceName)
            .claim("type", "service-to-service")
            .signWith(SignatureAlgorithm.HS256, tokenSecret)
            .compact();
    }
    
    // GET 请求
    public <T> T get(String path, Class<T> responseType) {
        HttpHeaders headers = createHeaders();
        HttpEntity<Void> entity = new HttpEntity<>(headers);
        
        ResponseEntity<T> response = restTemplate.exchange(
            kongUrl + path,
            HttpMethod.GET,
            entity,
            responseType
        );
        
        return response.getBody();
    }
    
    // POST 请求
    public <T, R> R post(String path, T body, Class<R> responseType) {
        HttpHeaders headers = createHeaders();
        HttpEntity<T> entity = new HttpEntity<>(body, headers);
        
        ResponseEntity<R> response = restTemplate.exchange(
            kongUrl + path,
            HttpMethod.POST,
            entity,
            responseType
        );
        
        return response.getBody();
    }
    
    // 创建请求头
    private HttpHeaders createHeaders() {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + generateServiceToken());
        headers.set("X-Service-Name", serviceName);
        headers.setContentType(MediaType.APPLICATION_JSON);
        return headers;
    }
}
```

#### Python 示例

```python
# service_client.py
import os
import jwt
import requests
from datetime import datetime, timedelta
from typing import Optional, Dict, Any

class ServiceClient:
    def __init__(self):
        self.kong_url = os.getenv('KONG_GATEWAY_URL', 'http://kong:8000')
        self.service_name = os.getenv('SERVICE_NAME')
        self.token_secret = os.getenv('SERVICE_TOKEN_SECRET')
        self.timeout = 5
    
    def _generate_service_token(self) -> str:
        """生成服务间调用 Token"""
        payload = {
            'service': self.service_name,
            'type': 'service-to-service',
            'exp': datetime.utcnow() + timedelta(hours=1)
        }
        return jwt.encode(payload, self.token_secret, algorithm='HS256')
    
    def _create_headers(self, extra_headers: Optional[Dict] = None) -> Dict:
        """创建请求头"""
        headers = {
            'Authorization': f'Bearer {self._generate_service_token()}',
            'X-Service-Name': self.service_name,
            'Content-Type': 'application/json'
        }
        if extra_headers:
            headers.update(extra_headers)
        return headers
    
    def get(self, path: str, headers: Optional[Dict] = None) -> Any:
        """GET 请求"""
        response = requests.get(
            f'{self.kong_url}{path}',
            headers=self._create_headers(headers),
            timeout=self.timeout
        )
        response.raise_for_status()
        return response.json()
    
    def post(self, path: str, data: Dict, headers: Optional[Dict] = None) -> Any:
        """POST 请求"""
        response = requests.post(
            f'{self.kong_url}{path}',
            json=data,
            headers=self._create_headers(headers),
            timeout=self.timeout
        )
        response.raise_for_status()
        return response.json()
    
    def put(self, path: str, data: Dict, headers: Optional[Dict] = None) -> Any:
        """PUT 请求"""
        response = requests.put(
            f'{self.kong_url}{path}',
            json=data,
            headers=self._create_headers(headers),
            timeout=self.timeout
        )
        response.raise_for_status()
        return response.json()
    
    def delete(self, path: str, headers: Optional[Dict] = None) -> Any:
        """DELETE 请求"""
        response = requests.delete(
            f'{self.kong_url}{path}',
            headers=self._create_headers(headers),
            timeout=self.timeout
        )
        response.raise_for_status()
        return response.json()

# 单例
service_client = ServiceClient()
```

---

## 鉴权模块集成

### 3.1 如何使用认证服务（S1）

#### 场景 1：验证用户 Token

**用户服务（S2）需要验证用户身份**：

```javascript
// user-service/middleware/auth.js
const serviceClient = require('../utils/serviceClient');

async function authenticateUser(req, res, next) {
  try {
    // 从请求头获取用户 Token
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }
    
    // 调用认证服务验证 Token
    const result = await serviceClient.post('/api/auth/verify', { token });
    
    if (!result.valid) {
      return res.status(401).json({ error: 'Invalid token' });
    }
    
    // 将用户信息附加到请求对象
    req.user = {
      id: result.userId,
      username: result.username,
      role: result.role
    };
    
    next();
  } catch (error) {
    res.status(500).json({ error: 'Authentication failed' });
  }
}

module.exports = authenticateUser;
```

**更优方案**：直接从 Kong 注入的 Header 获取

```javascript
// Kong 已经验证过 JWT，直接读取注入的 Header
function getUserFromHeaders(req) {
  return {
    id: req.headers['x-consumer-custom-id'],
    username: req.headers['x-consumer-username'],
    role: req.headers['x-jwt-claim-role']  // 从 JWT Payload 中提取
  };
}

// 使用
app.get('/api/users/:id', (req, res) => {
  const currentUser = getUserFromHeaders(req);
  
  // 权限检查
  if (currentUser.id !== req.params.id && currentUser.role !== 'admin') {
    return res.status(403).json({ error: 'Forbidden' });
  }
  
  // 业务逻辑...
});
```

#### 场景 2：检查用户权限

```javascript
// 调用认证服务检查权限
async function checkPermission(userId, permission) {
  const result = await serviceClient.get(
    `/api/auth/users/${userId}/permissions`
  );
  
  return result.permissions.includes(permission);
}

// 使用
app.delete('/api/posts/:id', async (req, res) => {
  const user = getUserFromHeaders(req);
  const post = await getPost(req.params.id);
  
  // 检查是否有删除权限
  const canDelete = post.authorId === user.id || 
                    await checkPermission(user.id, 'delete_any_post');
  
  if (!canDelete) {
    return res.status(403).json({ error: 'No permission' });
  }
  
  // 删除帖子...
});
```

#### 场景 3：创建用户（管理员）

```javascript
// admin-service 调用 auth-service 创建用户
app.post('/api/admin/users', async (req, res) => {
  const { username, password, role } = req.body;
  
  try {
    // 1. 调用认证服务创建认证账号
    const authResult = await serviceClient.post('/api/auth/users', {
      username,
      password,
      role
    });
    
    // 2. 调用用户服务创建用户资料
    const userResult = await serviceClient.post('/api/users', {
      userId: authResult.userId,
      nickname: username,
      avatar: '/default-avatar.png'
    });
    
    res.json({
      userId: authResult.userId,
      username: authResult.username,
      role: authResult.role
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to create user' });
  }
});
```

### 3.2 Kong 配置服务间调用

**允许服务 Token 访问**：

```yaml
# kong.yml
plugins:
  - name: jwt
    config:
      key_claim_name: kid
      claims_to_verify:
        - exp
      # 允许服务间调用的特殊 claim
      run_on_preflight: false
```

**服务间调用中间件**（Kong 插件）：

```lua
-- kong/plugins/service-auth/handler.lua
local jwt_decoder = require "kong.plugins.jwt.jwt_parser"

local ServiceAuthHandler = {
  PRIORITY = 1005,
  VERSION = "1.0.0",
}

function ServiceAuthHandler:access(conf)
  local token = kong.request.get_header("Authorization")
  
  if not token then
    return kong.response.exit(401, { message = "No token" })
  end
  
  token = token:gsub("Bearer ", "")
  local jwt, err = jwt_decoder:new(token)
  
  if err then
    return kong.response.exit(401, { message = "Invalid token" })
  end
  
  local claims = jwt.claims
  
  -- 检查是否为服务间调用
  if claims.type == "service-to-service" then
    kong.service.request.set_header("X-Service-Call", "true")
    kong.service.request.set_header("X-Calling-Service", claims.service)
  end
end

return ServiceAuthHandler
```

---

## 服务间调用示例

### 4.1 用户服务调用认证服务

**场景**：获取用户完整信息（资料 + 认证状态）

```javascript
// user-service/controllers/userController.js
const serviceClient = require('../utils/serviceClient');

async function getUserById(req, res) {
  const userId = req.params.id;
  
  try {
    // 1. 从本地数据库获取用户资料
    const profile = await db.query(
      'SELECT * FROM users_profile WHERE user_id = $1',
      [userId]
    );
    
    // 2. 调用认证服务获取认证信息
    const authInfo = await serviceClient.get(`/api/auth/users/${userId}`);
    
    // 3. 合并数据返回
    res.json({
      id: userId,
      username: authInfo.username,
      role: authInfo.role,
      status: authInfo.status,
      nickname: profile.nickname,
      avatar: profile.avatar,
      bio: profile.bio
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to get user' });
  }
}
```

### 4.2 内容服务调用用户服务

**场景**：获取帖子列表时附带作者信息

```python
# post-service/controllers/post_controller.py
from service_client import service_client

async def get_posts(request):
    # 1. 获取帖子列表
    posts = await db.fetch_all("SELECT * FROM posts ORDER BY created_at DESC LIMIT 20")
    
    # 2. 提取作者 ID
    author_ids = [post['author_id'] for post in posts]
    
    # 3. 批量调用用户服务获取作者信息
    authors = await service_client.post('/api/users/batch', {
        'user_ids': author_ids
    })
    
    # 4. 组装数据
    author_map = {author['id']: author for author in authors}
    
    result = []
    for post in posts:
        result.append({
            'id': post['id'],
            'title': post['title'],
            'content': post['content'],
            'author': author_map.get(post['author_id']),
            'created_at': post['created_at']
        })
    
    return {'posts': result}
```

### 4.3 互动服务调用内容服务

**场景**：发布回复前验证帖子是否存在

```javascript
// interaction-service/controllers/replyController.js
async function createReply(req, res) {
  const { postId, content } = req.body;
  const user = getUserFromHeaders(req);
  
  try {
    // 1. 调用内容服务验证帖子存在
    const post = await serviceClient.get(`/api/posts/${postId}`);
    
    if (!post) {
      return res.status(404).json({ error: 'Post not found' });
    }
    
    // 2. 创建回复
    const reply = await db.query(
      'INSERT INTO replies (post_id, user_id, content) VALUES ($1, $2, $3) RETURNING *',
      [postId, user.id, content]
    );
    
    // 3. 通知内容服务更新回复计数
    await serviceClient.post(`/api/posts/${postId}/increment-reply-count`);
    
    res.json(reply);
  } catch (error) {
    res.status(500).json({ error: 'Failed to create reply' });
  }
}
```

---

## 错误处理规范

### 5.1 统一错误响应格式

```json
{
  "code": 404,
  "message": "Resource not found",
  "details": {
    "resource": "post",
    "id": "12345"
  },
  "timestamp": "2025-10-23T10:30:00Z"
}
```

### 5.2 错误码定义

| HTTP 状态码 | 业务错误码 | 说明 | 处理建议 |
|------------|-----------|------|---------|
| 400 | 40001 | 参数错误 | 检查请求参数 |
| 401 | 40101 | 未认证 | 重新登录 |
| 403 | 40301 | 权限不足 | 提示用户无权限 |
| 404 | 40401 | 资源不存在 | 返回空或默认值 |
| 500 | 50001 | 服务内部错误 | 记录日志，返回通用错误 |
| 503 | 50301 | 服务不可用 | 降级处理或重试 |

### 5.3 服务调用错误处理

```javascript
async function callServiceWithFallback(serviceName, path, fallbackValue) {
  try {
    return await serviceClient.get(path);
  } catch (error) {
    // 记录错误日志
    logger.error(`Failed to call ${serviceName}:`, error);
    
    // 返回降级数据
    if (error.status === 503) {
      logger.warn(`${serviceName} unavailable, using fallback`);
      return fallbackValue;
    }
    
    // 其他错误抛出
    throw error;
  }
}

// 使用
const userInfo = await callServiceWithFallback(
  'user-service',
  `/api/users/${userId}`,
  { id: userId, nickname: 'Unknown User' }  // 降级数据
);
```

---

## 超时与重试策略

### 6.1 超时配置

```javascript
// 不同服务的超时时间
const TIMEOUTS = {
  'auth-service': 3000,    // 认证服务 3 秒
  'user-service': 5000,    // 用户服务 5 秒
  'post-service': 5000,    // 内容服务 5 秒
  'file-service': 10000,   // 文件服务 10 秒（上传较慢）
  'search-service': 8000   // 搜索服务 8 秒
};
```

### 6.2 重试策略

```javascript
const axios = require('axios');
const axiosRetry = require('axios-retry');

// 配置重试
axiosRetry(axios, {
  retries: 3,  // 最多重试 3 次
  retryDelay: axiosRetry.exponentialDelay,  // 指数退避
  retryCondition: (error) => {
    // 仅在网络错误或 5xx 错误时重试
    return axiosRetry.isNetworkOrIdempotentRequestError(error) ||
           (error.response && error.response.status >= 500);
  }
});
```

### 6.3 熔断器模式

```javascript
const CircuitBreaker = require('opossum');

// 创建熔断器
const breaker = new CircuitBreaker(serviceClient.get, {
  timeout: 5000,        // 超时时间
  errorThresholdPercentage: 50,  // 错误率超过 50% 时打开熔断器
  resetTimeout: 30000   // 30 秒后尝试恢复
});

// 使用熔断器
breaker.fire('/api/users/123')
  .then(data => console.log(data))
  .catch(err => console.error('Circuit breaker opened:', err));

// 监听事件
breaker.on('open', () => console.log('Circuit breaker opened'));
breaker.on('halfOpen', () => console.log('Circuit breaker half-open'));
breaker.on('close', () => console.log('Circuit breaker closed'));
```

---

## 最佳实践

### 7.1 服务调用清单

| 调用方 | 被调用方 | 接口 | 用途 | 是否必需 |
|-------|---------|------|------|---------|
| S2 用户 | S1 认证 | GET /api/auth/users/:id | 获取认证信息 | 是 |
| S3 内容 | S2 用户 | POST /api/users/batch | 批量获取作者信息 | 是 |
| S4 互动 | S3 内容 | GET /api/posts/:id | 验证帖子存在 | 是 |
| S8 管理 | S1 认证 | POST /api/auth/users | 创建用户 | 是 |

### 7.2 避免循环依赖

❌ **错误示例**：
```
S2 用户服务 → S3 内容服务 → S2 用户服务（循环）
```

✅ **正确方案**：
- 数据冗余：在 posts 表中存储 author_name
- 异步更新：通过消息队列同步数据
- 聚合服务：由 S8 管理服务统一聚合

### 7.3 缓存策略

```javascript
const Redis = require('ioredis');
const redis = new Redis();

async function getUserWithCache(userId) {
  // 1. 尝试从缓存获取
  const cached = await redis.get(`user:${userId}`);
  if (cached) {
    return JSON.parse(cached);
  }
  
  // 2. 调用服务获取
  const user = await serviceClient.get(`/api/users/${userId}`);
  
  // 3. 写入缓存（30 分钟）
  await redis.setex(`user:${userId}`, 1800, JSON.stringify(user));
  
  return user;
}
```

---

**文档维护**: 后端开发组  
**最后更新**: 2025-10-23

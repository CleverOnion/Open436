# M7 文件存储服务 - 存储抽象层设计

## 文档信息

**服务名称**: 文件存储服务 (file-service)  
**设计模式**: 策略模式 + 工厂模式  
**核心接口**: `StorageBackend` Trait  
**版本**: v1.0

---

## 目录

1. [设计概述](#设计概述)
2. [StorageBackend Trait 定义](#storagebackend-trait-定义)
3. [S3 存储实现](#s3-存储实现)
4. [本地存储实现](#本地存储实现)
5. [存储工厂](#存储工厂)
6. [配置管理](#配置管理)
7. [错误处理](#错误处理)
8. [使用示例](#使用示例)

---

## 设计概述

### 设计目标

1. **抽象存储层**: 通过 Trait 抽象存储操作，解耦业务逻辑与存储实现
2. **多后端支持**: 支持 Minio、AWS S3、阿里云 OSS、本地存储等
3. **易于扩展**: 新增存储后端只需实现 `StorageBackend` Trait
4. **配置驱动**: 通过配置文件切换不同存储后端，无需修改代码

### 设计模式

#### 策略模式 (Strategy Pattern)

定义一系列存储算法（S3、本地等），将每个算法封装起来，使它们可以互相替换。

```
┌──────────────────────────────────────────┐
│        StorageBackend Trait              │
│  (定义存储操作的统一接口)                 │
├──────────────────────────────────────────┤
│ + upload(key, data, content_type)        │
│ + download(key)                          │
│ + delete(key)                            │
│ + get_url(key)                           │
│ + exists(key)                            │
└──────────────┬───────────────────────────┘
               │ 实现
      ┌────────┴──────────┐
      │                   │
┌─────▼─────┐       ┌────▼──────┐
│S3Storage  │       │LocalStorage│
│Backend    │       │Backend     │
└───────────┘       └────────────┘
  支持:               支持:
  - Minio            - 本地文件系统
  - AWS S3
  - 阿里云 OSS
```

#### 工厂模式 (Factory Pattern)

根据配置创建相应的存储后端实例。

```rust
pub fn create_storage(config: &StorageConfig) -> Arc<dyn StorageBackend> {
    match config.backend_type.as_str() {
        "s3" => Arc::new(S3StorageBackend::new(config)),
        "local" => Arc::new(LocalStorageBackend::new(config)),
        _ => panic!("Unsupported storage backend"),
    }
}
```

### 优势

- ✅ **开闭原则**: 对扩展开放，对修改关闭
- ✅ **依赖倒置**: 业务代码依赖抽象（Trait），不依赖具体实现
- ✅ **单一职责**: 每个实现只关注一种存储方式
- ✅ **可测试性**: 易于编写 Mock 实现进行单元测试

---

## StorageBackend Trait 定义

### Trait 接口

```rust
// src/storage/backend.rs
use async_trait::async_trait;
use anyhow::Result;

/// 存储后端抽象接口
#[async_trait]
pub trait StorageBackend: Send + Sync {
    /// 上传文件
    ///
    /// # 参数
    /// - `key`: 存储路径/键（如：2025/10/28/uuid.jpg）
    /// - `data`: 文件二进制数据
    /// - `content_type`: MIME 类型（如：image/jpeg）
    ///
    /// # 返回
    /// - `Ok(url)`: 上传成功，返回访问 URL
    /// - `Err(e)`: 上传失败
    async fn upload(
        &self,
        key: &str,
        data: Vec<u8>,
        content_type: &str,
    ) -> Result<String>;

    /// 下载文件
    ///
    /// # 参数
    /// - `key`: 存储路径/键
    ///
    /// # 返回
    /// - `Ok(data)`: 下载成功，返回文件数据
    /// - `Err(e)`: 下载失败（如文件不存在）
    async fn download(&self, key: &str) -> Result<Vec<u8>>;

    /// 删除文件
    ///
    /// # 参数
    /// - `key`: 存储路径/键
    ///
    /// # 返回
    /// - `Ok(())`: 删除成功
    /// - `Err(e)`: 删除失败
    async fn delete(&self, key: &str) -> Result<()>;

    /// 获取文件访问 URL
    ///
    /// # 参数
    /// - `key`: 存储路径/键
    ///
    /// # 返回
    /// - `Ok(url)`: 返回可访问的 URL
    /// - `Err(e)`: 获取失败
    async fn get_url(&self, key: &str) -> Result<String>;

    /// 检查文件是否存在
    ///
    /// # 参数
    /// - `key`: 存储路径/键
    ///
    /// # 返回
    /// - `Ok(true)`: 文件存在
    /// - `Ok(false)`: 文件不存在
    /// - `Err(e)`: 检查失败
    async fn exists(&self, key: &str) -> Result<bool>;
}
```

### 设计说明

#### 1. 异步接口

使用 `async_trait` 宏支持异步方法：

- 文件 I/O 是典型的异步操作
- 与 Actix-web 异步框架配合
- 提高并发性能

#### 2. Send + Sync 约束

```rust
pub trait StorageBackend: Send + Sync
```

- `Send`: 可以在线程间安全传递
- `Sync`: 可以在多线程中安全共享引用
- 允许在 Actix-web 的多线程运行时中使用

#### 3. Result 返回类型

使用 `anyhow::Result` 统一错误处理：

```rust
async fn upload(&self, key: &str, data: Vec<u8>, content_type: &str) -> Result<String>;
```

- 简化错误传播（`?` 操作符）
- 支持错误上下文（`.context()` 方法）

---

## S3 存储实现

### 实现代码

```rust
// src/storage/s3.rs
use async_trait::async_trait;
use anyhow::{Context, Result};
use aws_sdk_s3::{Client, config::Region, primitives::ByteStream};
use aws_config::meta::region::RegionProviderChain;
use aws_credential_types::Credentials;
use std::sync::Arc;

use super::backend::StorageBackend;
use crate::config::S3Config;

/// S3 存储后端（支持 Minio、AWS S3、阿里云 OSS 等 S3 兼容服务）
pub struct S3StorageBackend {
    client: Client,
    bucket: String,
    public_url: String,
    endpoint: Option<String>,
}

impl S3StorageBackend {
    /// 创建 S3 存储后端
    pub async fn new(config: &S3Config) -> Self {
        // 配置凭证
        let credentials = Credentials::new(
            &config.access_key,
            &config.secret_key,
            None,
            None,
            "static",
        );

        // 配置区域
        let region_provider = RegionProviderChain::first_try(
            Region::new(config.region.clone())
        );

        // 构建 AWS SDK 配置
        let mut sdk_config = aws_config::from_env()
            .region(region_provider)
            .credentials_provider(credentials)
            .load()
            .await;

        // 如果是 Minio 或自定义端点，设置 endpoint
        let mut s3_config = aws_sdk_s3::config::Builder::from(&sdk_config);
        
        if let Some(endpoint) = &config.endpoint {
            s3_config = s3_config
                .endpoint_url(endpoint)
                .force_path_style(config.path_style);  // Minio 需要 path-style
        }

        let client = Client::from_conf(s3_config.build());

        Self {
            client,
            bucket: config.bucket.clone(),
            public_url: config.public_url.clone(),
            endpoint: config.endpoint.clone(),
        }
    }
}

#[async_trait]
impl StorageBackend for S3StorageBackend {
    async fn upload(
        &self,
        key: &str,
        data: Vec<u8>,
        content_type: &str,
    ) -> Result<String> {
        let byte_stream = ByteStream::from(data);

        self.client
            .put_object()
            .bucket(&self.bucket)
            .key(key)
            .body(byte_stream)
            .content_type(content_type)
            .send()
            .await
            .context(format!("Failed to upload file to S3: {}", key))?;

        // 返回公开访问 URL
        let url = format!("{}/{}", self.public_url, key);
        Ok(url)
    }

    async fn download(&self, key: &str) -> Result<Vec<u8>> {
        let response = self.client
            .get_object()
            .bucket(&self.bucket)
            .key(key)
            .send()
            .await
            .context(format!("Failed to download file from S3: {}", key))?;

        let data = response
            .body
            .collect()
            .await
            .context("Failed to read S3 object body")?
            .into_bytes()
            .to_vec();

        Ok(data)
    }

    async fn delete(&self, key: &str) -> Result<()> {
        self.client
            .delete_object()
            .bucket(&self.bucket)
            .key(key)
            .send()
            .await
            .context(format!("Failed to delete file from S3: {}", key))?;

        Ok(())
    }

    async fn get_url(&self, key: &str) -> Result<String> {
        // 返回公开访问 URL
        let url = format!("{}/{}", self.public_url, key);
        Ok(url)
    }

    async fn exists(&self, key: &str) -> Result<bool> {
        match self.client
            .head_object()
            .bucket(&self.bucket)
            .key(key)
            .send()
            .await
        {
            Ok(_) => Ok(true),
            Err(e) => {
                // 404 表示文件不存在
                if e.to_string().contains("404") || e.to_string().contains("NotFound") {
                    Ok(false)
                } else {
                    Err(e.into())
                }
            }
        }
    }
}
```

### 特性说明

#### 1. S3 兼容性

支持所有 S3 兼容的存储服务：

| 服务           | 配置                                          |
| -------------- | --------------------------------------------- |
| **Minio**      | endpoint: `http://localhost:9000`<br>path_style: `true` |
| **AWS S3**     | endpoint: 留空<br>region: `us-east-1`          |
| **阿里云 OSS** | endpoint: `https://oss-cn-hangzhou.aliyuncs.com`<br>region: `oss-cn-hangzhou` |
| **腾讯云 COS** | endpoint: `https://cos.ap-guangzhou.myqcloud.com`<br>region: `ap-guangzhou` |

#### 2. Path-Style vs Virtual-Hosted-Style

```rust
// Path-Style (Minio 需要)
// http://localhost:9000/bucket-name/2025/10/28/file.jpg
s3_config = s3_config.force_path_style(true);

// Virtual-Hosted-Style (AWS S3 默认)
// https://bucket-name.s3.amazonaws.com/2025/10/28/file.jpg
s3_config = s3_config.force_path_style(false);
```

#### 3. 公开访问 URL

```rust
pub_url = format!("{}/{}", self.public_url, key);
// 示例: http://localhost:9000/open436-files/2025/10/28/uuid.jpg
```

---

## 本地存储实现

### 实现代码

```rust
// src/storage/local.rs
use async_trait::async_trait;
use anyhow::{Context, Result};
use tokio::fs;
use std::path::{Path, PathBuf};

use super::backend::StorageBackend;
use crate::config::LocalConfig;

/// 本地文件系统存储后端（用于开发/测试）
pub struct LocalStorageBackend {
    base_path: PathBuf,
    public_url: String,
}

impl LocalStorageBackend {
    /// 创建本地存储后端
    pub async fn new(config: &LocalConfig) -> Result<Self> {
        let base_path = PathBuf::from(&config.storage_path);

        // 创建存储目录
        if !base_path.exists() {
            fs::create_dir_all(&base_path)
                .await
                .context("Failed to create storage directory")?;
        }

        Ok(Self {
            base_path,
            public_url: config.public_url.clone(),
        })
    }

    /// 获取文件的完整路径
    fn get_full_path(&self, key: &str) -> PathBuf {
        self.base_path.join(key)
    }
}

#[async_trait]
impl StorageBackend for LocalStorageBackend {
    async fn upload(
        &self,
        key: &str,
        data: Vec<u8>,
        _content_type: &str,
    ) -> Result<String> {
        let file_path = self.get_full_path(key);

        // 创建父目录
        if let Some(parent) = file_path.parent() {
            fs::create_dir_all(parent)
                .await
                .context("Failed to create parent directory")?;
        }

        // 写入文件
        fs::write(&file_path, data)
            .await
            .context(format!("Failed to write file: {}", key))?;

        // 返回公开访问 URL
        let url = format!("{}/{}", self.public_url, key);
        Ok(url)
    }

    async fn download(&self, key: &str) -> Result<Vec<u8>> {
        let file_path = self.get_full_path(key);

        fs::read(&file_path)
            .await
            .context(format!("Failed to read file: {}", key))
    }

    async fn delete(&self, key: &str) -> Result<()> {
        let file_path = self.get_full_path(key);

        fs::remove_file(&file_path)
            .await
            .context(format!("Failed to delete file: {}", key))?;

        Ok(())
    }

    async fn get_url(&self, key: &str) -> Result<String> {
        let url = format!("{}/{}", self.public_url, key);
        Ok(url)
    }

    async fn exists(&self, key: &str) -> Result<bool> {
        let file_path = self.get_full_path(key);
        Ok(file_path.exists())
    }
}
```

### 特性说明

#### 1. 适用场景

- **开发环境**: 无需配置 Minio，快速启动
- **测试环境**: 测试文件操作逻辑
- **小型部署**: 单机部署，文件量小

#### 2. 目录结构

```
./storage/
├── 2025/
│   ├── 10/
│   │   ├── 28/
│   │   │   ├── a1b2c3d4-e5f6-4789-a1b2-c3d4e5f67890.jpg
│   │   │   └── b2c3d4e5-f6a7-4890-b2c3-d4e5f6a78901.png
│   │   └── 29/
│   └── 11/
└── 2026/
```

#### 3. URL 生成

```rust
// 配置
public_url = "http://localhost:8007/files"

// 生成 URL
url = format!("{}/{}", public_url, key);
// 示例: http://localhost:8007/files/2025/10/28/uuid.jpg
```

需要在 Actix-web 中配置静态文件服务：

```rust
use actix_files as fs;

App::new()
    .service(fs::Files::new("/files", "./storage").show_files_listing())
```

---

## 存储工厂

### 工厂实现

```rust
// src/storage/factory.rs
use std::sync::Arc;
use crate::config::StorageConfig;
use super::backend::StorageBackend;
use super::s3::S3StorageBackend;
use super::local::LocalStorageBackend;

/// 创建存储后端实例（工厂模式）
pub async fn create_storage(config: &StorageConfig) -> Arc<dyn StorageBackend> {
    match config.backend_type.as_str() {
        "s3" => {
            let s3_config = config.s3.as_ref()
                .expect("S3 config is required when backend_type is 's3'");
            Arc::new(S3StorageBackend::new(s3_config).await)
        }
        "local" => {
            let local_config = config.local.as_ref()
                .expect("Local config is required when backend_type is 'local'");
            Arc::new(
                LocalStorageBackend::new(local_config)
                    .await
                    .expect("Failed to create local storage backend")
            )
        }
        _ => panic!("Unsupported storage backend: {}", config.backend_type),
    }
}
```

### 使用方式

```rust
// main.rs
use std::sync::Arc;

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // 加载配置
    let config = Config::from_env();

    // 创建存储后端（通过工厂）
    let storage = storage::factory::create_storage(&config.storage).await;

    // 注入到 Actix-web
    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(storage.clone()))
            .configure(handlers::configure_routes)
    })
    .bind(("0.0.0.0", 8007))?
    .run()
    .await
}
```

---

## 配置管理

### 配置结构

```rust
// src/config.rs
use serde::Deserialize;

#[derive(Debug, Clone, Deserialize)]
pub struct StorageConfig {
    pub backend_type: String,  // "s3" 或 "local"
    pub s3: Option<S3Config>,
    pub local: Option<LocalConfig>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct S3Config {
    pub endpoint: Option<String>,     // Minio/自定义端点
    pub region: String,                // 区域（如 us-east-1）
    pub bucket: String,                // Bucket 名称
    pub access_key: String,            // Access Key
    pub secret_key: String,            // Secret Key
    pub public_url: String,            // 公开访问 URL
    pub path_style: bool,              // 是否使用 Path-Style（Minio 需要）
}

#[derive(Debug, Clone, Deserialize)]
pub struct LocalConfig {
    pub storage_path: String,          // 存储路径（如 ./storage）
    pub public_url: String,            // 公开访问 URL
}

impl StorageConfig {
    pub fn from_env() -> Self {
        let backend_type = std::env::var("STORAGE_BACKEND")
            .unwrap_or_else(|_| "s3".to_string());

        let s3 = if backend_type == "s3" {
            Some(S3Config {
                endpoint: std::env::var("S3_ENDPOINT").ok(),
                region: std::env::var("S3_REGION")
                    .unwrap_or_else(|_| "us-east-1".to_string()),
                bucket: std::env::var("S3_BUCKET")
                    .expect("S3_BUCKET must be set"),
                access_key: std::env::var("S3_ACCESS_KEY")
                    .expect("S3_ACCESS_KEY must be set"),
                secret_key: std::env::var("S3_SECRET_KEY")
                    .expect("S3_SECRET_KEY must be set"),
                public_url: std::env::var("S3_PUBLIC_URL")
                    .expect("S3_PUBLIC_URL must be set"),
                path_style: std::env::var("S3_PATH_STYLE")
                    .unwrap_or_else(|_| "true".to_string())
                    .parse()
                    .unwrap_or(true),
            })
        } else {
            None
        };

        let local = if backend_type == "local" {
            Some(LocalConfig {
                storage_path: std::env::var("LOCAL_STORAGE_PATH")
                    .unwrap_or_else(|_| "./storage".to_string()),
                public_url: std::env::var("LOCAL_PUBLIC_URL")
                    .unwrap_or_else(|_| "http://localhost:8007/files".to_string()),
            })
        } else {
            None
        };

        Self {
            backend_type,
            s3,
            local,
        }
    }
}
```

### 环境变量配置

#### S3 配置 (Minio)

```bash
STORAGE_BACKEND=s3
S3_ENDPOINT=http://localhost:9000
S3_REGION=us-east-1
S3_BUCKET=open436-files
S3_ACCESS_KEY=minioadmin
S3_SECRET_KEY=minioadmin
S3_PUBLIC_URL=http://localhost:9000/open436-files
S3_PATH_STYLE=true
```

#### S3 配置 (AWS S3)

```bash
STORAGE_BACKEND=s3
# S3_ENDPOINT 留空（使用默认 AWS 端点）
S3_REGION=us-west-2
S3_BUCKET=open436-prod-files
S3_ACCESS_KEY=AKIAIOSFODNN7EXAMPLE
S3_SECRET_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
S3_PUBLIC_URL=https://open436-prod-files.s3.us-west-2.amazonaws.com
S3_PATH_STYLE=false
```

#### 本地配置

```bash
STORAGE_BACKEND=local
LOCAL_STORAGE_PATH=./storage
LOCAL_PUBLIC_URL=http://localhost:8007/files
```

---

## 错误处理

### 自定义错误类型

```rust
// src/utils/error.rs
use thiserror::Error;

#[derive(Error, Debug)]
pub enum StorageError {
    #[error("File not found: {0}")]
    FileNotFound(String),

    #[error("Upload failed: {0}")]
    UploadFailed(String),

    #[error("Download failed: {0}")]
    DownloadFailed(String),

    #[error("Delete failed: {0}")]
    DeleteFailed(String),

    #[error("S3 error: {0}")]
    S3Error(#[from] aws_sdk_s3::Error),

    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
}
```

### 错误处理示例

```rust
use anyhow::Context;

async fn upload_file(
    storage: &dyn StorageBackend,
    key: &str,
    data: Vec<u8>,
) -> Result<String> {
    storage
        .upload(key, data, "image/jpeg")
        .await
        .context(format!("Failed to upload file: {}", key))?;

    Ok(url)
}
```

---

## 使用示例

### 在 Handler 中使用

```rust
// src/handlers/upload.rs
use actix_web::{web, HttpResponse};
use std::sync::Arc;
use crate::storage::backend::StorageBackend;

pub async fn upload_handler(
    storage: web::Data<Arc<dyn StorageBackend>>,
    file_data: web::Bytes,
) -> Result<HttpResponse, actix_web::Error> {
    let key = "2025/10/28/test.jpg";
    let data = file_data.to_vec();

    // 调用存储后端上传文件
    let url = storage
        .upload(key, data, "image/jpeg")
        .await
        .map_err(|e| actix_web::error::ErrorInternalServerError(e))?;

    Ok(HttpResponse::Ok().json(json!({
        "url": url
    })))
}
```

### 在测试中使用 Mock

```rust
// tests/storage_test.rs
use mockall::predicate::*;
use mockall::mock;

mock! {
    pub StorageBackend {}

    #[async_trait]
    impl StorageBackend for StorageBackend {
        async fn upload(&self, key: &str, data: Vec<u8>, content_type: &str) -> Result<String>;
        async fn download(&self, key: &str) -> Result<Vec<u8>>;
        async fn delete(&self, key: &str) -> Result<()>;
        async fn get_url(&self, key: &str) -> Result<String>;
        async fn exists(&self, key: &str) -> Result<bool>;
    }
}

#[tokio::test]
async fn test_upload() {
    let mut mock = MockStorageBackend::new();
    mock.expect_upload()
        .with(eq("test.jpg"), always(), eq("image/jpeg"))
        .times(1)
        .returning(|_, _, _| Ok("http://example.com/test.jpg".to_string()));

    let url = mock.upload("test.jpg", vec![1, 2, 3], "image/jpeg").await.unwrap();
    assert_eq!(url, "http://example.com/test.jpg");
}
```

---

## 扩展新后端

### 示例：Azure Blob Storage

```rust
// src/storage/azure.rs
use async_trait::async_trait;
use anyhow::Result;
use super::backend::StorageBackend;

pub struct AzureBlobBackend {
    container: String,
    connection_string: String,
}

impl AzureBlobBackend {
    pub async fn new(config: &AzureConfig) -> Self {
        Self {
            container: config.container.clone(),
            connection_string: config.connection_string.clone(),
        }
    }
}

#[async_trait]
impl StorageBackend for AzureBlobBackend {
    async fn upload(&self, key: &str, data: Vec<u8>, content_type: &str) -> Result<String> {
        // 实现 Azure Blob 上传逻辑
        todo!()
    }

    // ... 实现其他方法
}
```

在工厂中添加：

```rust
pub async fn create_storage(config: &StorageConfig) -> Arc<dyn StorageBackend> {
    match config.backend_type.as_str() {
        "s3" => Arc::new(S3StorageBackend::new(&config.s3).await),
        "local" => Arc::new(LocalStorageBackend::new(&config.local).await.unwrap()),
        "azure" => Arc::new(AzureBlobBackend::new(&config.azure).await),  // 新增
        _ => panic!("Unsupported storage backend"),
    }
}
```

---

**文档版本**: v1.0  
**创建日期**: 2025-10-28  
**最后更新**: 2025-10-28


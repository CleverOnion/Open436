# M7 文件存储服务 - 数据库设计

## 文档信息

**服务名称**: 文件存储服务 (file-service)  
**数据库**: PostgreSQL 14+  
**Schema**: `file_db` (在 `open436_db` 数据库中，与 M1 共享实例)  
**版本**: v1.0

---

## 目录

1. [数据库概述](#数据库概述)
2. [表结构设计](#表结构设计)
3. [索引设计](#索引设计)
4. [数据关系图](#数据关系图)
5. [数据约束与验证](#数据约束与验证)
6. [数据迁移](#数据迁移)
7. [性能优化](#性能优化)

---

## 数据库概述

### 设计原则

1. **Schema 隔离**: 使用独立 Schema `file_db`，与 M1 的 `public` Schema 隔离
2. **共享实例**: 与 M1 认证授权服务共享同一个 PostgreSQL 实例 `open436_db`
3. **职责单一**: 仅存储文件元数据和使用关联，不涉及业务逻辑
4. **性能优先**: 合理使用索引、枚举类型，支持高并发查询

### 与其他模块的关系

| M7 文件存储服务          | M1 认证授权服务   | 关联方式      |
| ------------------------ | ----------------- | ------------- |
| `file_db.files` 表       | `public.users_auth` 表 | uploader_id (逻辑外键) |
| uploader_id (INTEGER)    | id (SERIAL)       | 跨 Schema 关联 |

**说明**:

- `file_db.files.uploader_id` 关联 `public.users_auth.id`（逻辑外键，不使用物理外键）
- 跨 Schema 不设置物理外键，通过应用层保证数据一致性

### 表列表

| 表名              | 说明           | 记录数估算  |
| ----------------- | -------------- | ----------- |
| `files`           | 文件元数据表   | 10000-100000|
| `file_usages`     | 文件使用关联表 | 10000-100000|
| `cleanup_logs`    | 清理日志表     | 365-1000    |

---

## 表结构设计

### 1. files - 文件元数据表

**用途**: 存储文件的元数据信息（路径、类型、大小、状态等）

```sql
-- 创建文件类型枚举
CREATE TYPE file_db.file_type AS ENUM (
    'avatar',       -- 用户头像
    'post',         -- 帖子图片
    'reply',        -- 回复图片
    'section_icon'  -- 板块图标
);

-- 创建文件状态枚举
CREATE TYPE file_db.file_status AS ENUM (
    'unused',   -- 未使用
    'used',     -- 已使用
    'deleted'   -- 已删除
);

-- 创建文件表
CREATE TABLE file_db.files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    filename VARCHAR(255) NOT NULL,
    storage_key VARCHAR(500) NOT NULL UNIQUE,
    file_type file_db.file_type NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    file_size BIGINT NOT NULL,
    uploader_id INTEGER NOT NULL,
    status file_db.file_status NOT NULL DEFAULT 'unused',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT chk_filename_not_empty CHECK (LENGTH(filename) > 0),
    CONSTRAINT chk_storage_key_not_empty CHECK (LENGTH(storage_key) > 0),
    CONSTRAINT chk_file_size_positive CHECK (file_size > 0),
    CONSTRAINT chk_uploader_id_positive CHECK (uploader_id > 0)
);

-- 添加注释
COMMENT ON TABLE file_db.files IS '文件元数据表';
COMMENT ON COLUMN file_db.files.id IS '文件ID（UUID）';
COMMENT ON COLUMN file_db.files.filename IS '原始文件名（如：avatar.jpg）';
COMMENT ON COLUMN file_db.files.storage_key IS '存储路径/键（如：2025/10/28/uuid.jpg）';
COMMENT ON COLUMN file_db.files.file_type IS '文件类型：avatar/post/reply/section_icon';
COMMENT ON COLUMN file_db.files.mime_type IS 'MIME类型（如：image/jpeg）';
COMMENT ON COLUMN file_db.files.file_size IS '文件大小（字节）';
COMMENT ON COLUMN file_db.files.uploader_id IS '上传者ID（关联 public.users_auth.id）';
COMMENT ON COLUMN file_db.files.status IS '文件状态：unused/used/deleted';
COMMENT ON COLUMN file_db.files.created_at IS '上传时间';
COMMENT ON COLUMN file_db.files.updated_at IS '更新时间';
```

**字段说明**:

| 字段         | 类型            | 约束                | 说明                                    |
| ------------ | --------------- | ------------------- | --------------------------------------- |
| `id`         | UUID            | PRIMARY KEY         | 文件唯一标识（使用 UUID v4）            |
| `filename`   | VARCHAR(255)    | NOT NULL            | 原始文件名（如 `avatar.jpg`）           |
| `storage_key`| VARCHAR(500)    | NOT NULL, UNIQUE    | 存储路径（如 `2025/10/28/uuid.jpg`）    |
| `file_type`  | file_type ENUM  | NOT NULL            | 文件类型枚举                            |
| `mime_type`  | VARCHAR(100)    | NOT NULL            | MIME 类型（如 `image/jpeg`）            |
| `file_size`  | BIGINT          | NOT NULL            | 文件大小（字节）                        |
| `uploader_id`| INTEGER         | NOT NULL            | 上传者 ID（逻辑外键）                   |
| `status`     | file_status ENUM| NOT NULL, DEFAULT   | 文件状态                                |
| `created_at` | TIMESTAMP       | NOT NULL            | 上传时间                                |
| `updated_at` | TIMESTAMP       | NOT NULL            | 更新时间                                |

**业务规则**:

- 文件 ID 使用 UUID v4，保证全局唯一
- `storage_key` 按日期分目录：`YYYY/MM/DD/uuid.ext`
- `filename` 保留原始文件名，用于下载时的文件名
- `mime_type` 通过文件魔数验证，不仅依赖扩展名
- `status` 初始为 `unused`，被引用后变为 `used`

**示例数据**:

```sql
INSERT INTO file_db.files (id, filename, storage_key, file_type, mime_type, file_size, uploader_id, status) VALUES
('a1b2c3d4-e5f6-4789-a1b2-c3d4e5f67890', 'avatar.jpg', '2025/10/28/a1b2c3d4-e5f6-4789-a1b2-c3d4e5f67890.jpg', 'avatar', 'image/jpeg', 153600, 1, 'used'),
('b2c3d4e5-f6a7-4890-b2c3-d4e5f6a78901', 'post-image.png', '2025/10/28/b2c3d4e5-f6a7-4890-b2c3-d4e5f6a78901.png', 'post', 'image/png', 524288, 2, 'used'),
('c3d4e5f6-a7b8-4901-c3d4-e5f6a7b89012', 'temp.gif', '2025/10/28/c3d4e5f6-a7b8-4901-c3d4-e5f6a7b89012.gif', 'post', 'image/gif', 204800, 3, 'unused');
```

---

### 2. file_usages - 文件使用关联表

**用途**: 记录文件被哪些业务实体使用（多对多关系）

```sql
CREATE TABLE file_db.file_usages (
    id SERIAL PRIMARY KEY,
    file_id UUID NOT NULL,
    usage_type VARCHAR(20) NOT NULL,
    usage_id INTEGER NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT fk_file FOREIGN KEY (file_id) 
        REFERENCES file_db.files(id) ON DELETE CASCADE,
    CONSTRAINT uk_file_usage UNIQUE (file_id, usage_type, usage_id),
    CONSTRAINT chk_usage_type CHECK (usage_type IN ('post', 'reply', 'avatar', 'section_icon')),
    CONSTRAINT chk_usage_id_positive CHECK (usage_id > 0)
);

-- 添加注释
COMMENT ON TABLE file_db.file_usages IS '文件使用关联表';
COMMENT ON COLUMN file_db.file_usages.id IS '关联ID（自增主键）';
COMMENT ON COLUMN file_db.file_usages.file_id IS '文件ID（外键）';
COMMENT ON COLUMN file_db.file_usages.usage_type IS '使用类型：post/reply/avatar/section_icon';
COMMENT ON COLUMN file_db.file_usages.usage_id IS '使用位置ID（帖子ID/回复ID/用户ID/板块ID）';
COMMENT ON COLUMN file_db.file_usages.created_at IS '关联创建时间';
```

**字段说明**:

| 字段         | 类型         | 约束                  | 说明                                    |
| ------------ | ------------ | --------------------- | --------------------------------------- |
| `id`         | SERIAL       | PRIMARY KEY           | 关联 ID                                 |
| `file_id`    | UUID         | NOT NULL, FK          | 文件 ID（外键）                         |
| `usage_type` | VARCHAR(20)  | NOT NULL              | 使用类型（post/reply/avatar/section_icon）|
| `usage_id`   | INTEGER      | NOT NULL              | 使用位置 ID                             |
| `created_at` | TIMESTAMP    | NOT NULL              | 关联创建时间                            |

**业务规则**:

- 一个文件可以被多个业务实体使用（如一张图片被多个帖子引用）
- 同一文件不能重复关联同一业务实体（通过 UNIQUE 约束）
- 删除文件时，级联删除所有使用关联
- `usage_type` 和 `usage_id` 组合指向业务实体：
  - `post` + `usage_id` → 帖子 ID（M3）
  - `reply` + `usage_id` → 回复 ID（M4）
  - `avatar` + `usage_id` → 用户 ID（M2）
  - `section_icon` + `usage_id` → 板块 ID（M5）

**示例数据**:

```sql
INSERT INTO file_db.file_usages (file_id, usage_type, usage_id) VALUES
('a1b2c3d4-e5f6-4789-a1b2-c3d4e5f67890', 'avatar', 1),  -- 用户 1 的头像
('b2c3d4e5-f6a7-4890-b2c3-d4e5f6a78901', 'post', 101),  -- 帖子 101 的图片
('b2c3d4e5-f6a7-4890-b2c3-d4e5f6a78901', 'post', 102);  -- 同一图片被帖子 102 引用
```

---

### 3. cleanup_logs - 清理日志表

**用途**: 记录自动清理任务的执行日志

```sql
CREATE TABLE file_db.cleanup_logs (
    id SERIAL PRIMARY KEY,
    cleanup_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    files_deleted INTEGER NOT NULL DEFAULT 0,
    space_freed BIGINT NOT NULL DEFAULT 0,
    duration_ms INTEGER,
    status VARCHAR(20) NOT NULL DEFAULT 'success',
    error_message TEXT,
    
    CONSTRAINT chk_files_deleted_positive CHECK (files_deleted >= 0),
    CONSTRAINT chk_space_freed_positive CHECK (space_freed >= 0),
    CONSTRAINT chk_status CHECK (status IN ('success', 'partial', 'failed'))
);

-- 添加注释
COMMENT ON TABLE file_db.cleanup_logs IS '自动清理日志表';
COMMENT ON COLUMN file_db.cleanup_logs.id IS '日志ID（自增主键）';
COMMENT ON COLUMN file_db.cleanup_logs.cleanup_time IS '清理时间';
COMMENT ON COLUMN file_db.cleanup_logs.files_deleted IS '删除文件数';
COMMENT ON COLUMN file_db.cleanup_logs.space_freed IS '释放空间（字节）';
COMMENT ON COLUMN file_db.cleanup_logs.duration_ms IS '执行时长（毫秒）';
COMMENT ON COLUMN file_db.cleanup_logs.status IS '执行状态：success/partial/failed';
COMMENT ON COLUMN file_db.cleanup_logs.error_message IS '错误信息（失败时）';
```

**字段说明**:

| 字段            | 类型        | 约束        | 说明                          |
| --------------- | ----------- | ----------- | ----------------------------- |
| `id`            | SERIAL      | PRIMARY KEY | 日志 ID                       |
| `cleanup_time`  | TIMESTAMP   | NOT NULL    | 清理时间                      |
| `files_deleted` | INTEGER     | NOT NULL    | 删除文件数                    |
| `space_freed`   | BIGINT      | NOT NULL    | 释放空间（字节）              |
| `duration_ms`   | INTEGER     | NULL        | 执行时长（毫秒）              |
| `status`        | VARCHAR(20) | NOT NULL    | 执行状态                      |
| `error_message` | TEXT        | NULL        | 错误信息（失败时记录）        |

**业务规则**:

- 每次清理任务执行完成后插入一条日志
- `status`:
  - `success`: 全部成功
  - `partial`: 部分成功（某些文件删除失败）
  - `failed`: 完全失败
- 保留所有清理日志，供统计分析

**示例数据**:

```sql
INSERT INTO file_db.cleanup_logs (cleanup_time, files_deleted, space_freed, duration_ms, status) VALUES
('2025-10-27 02:00:00', 15, 7864320, 1250, 'success'),
('2025-10-28 02:00:00', 8, 4194304, 980, 'success'),
('2025-10-29 02:00:00', 0, 0, 120, 'success');  -- 无文件需清理
```

---

## 索引设计

### 主键索引（自动创建）

```sql
-- files 表
CREATE INDEX ON file_db.files(id);  -- UUID 主键

-- file_usages 表
CREATE INDEX ON file_db.file_usages(id);  -- SERIAL 主键

-- cleanup_logs 表
CREATE INDEX ON file_db.cleanup_logs(id);  -- SERIAL 主键
```

### 唯一索引

```sql
-- files 表：storage_key 唯一索引
CREATE UNIQUE INDEX idx_files_storage_key ON file_db.files(storage_key);

-- file_usages 表：防止重复关联
CREATE UNIQUE INDEX idx_file_usages_unique 
    ON file_db.file_usages(file_id, usage_type, usage_id);
```

### 普通索引

```sql
-- files 表
CREATE INDEX idx_files_uploader_id ON file_db.files(uploader_id);
CREATE INDEX idx_files_status ON file_db.files(status);
CREATE INDEX idx_files_file_type ON file_db.files(file_type);
CREATE INDEX idx_files_created_at ON file_db.files(created_at);

-- 复合索引：用于清理任务查询（status='unused' AND created_at < threshold）
CREATE INDEX idx_files_status_created 
    ON file_db.files(status, created_at) 
    WHERE status = 'unused';

-- file_usages 表
CREATE INDEX idx_file_usages_file_id ON file_db.file_usages(file_id);
CREATE INDEX idx_file_usages_usage ON file_db.file_usages(usage_type, usage_id);

-- cleanup_logs 表
CREATE INDEX idx_cleanup_logs_time ON file_db.cleanup_logs(cleanup_time DESC);
CREATE INDEX idx_cleanup_logs_status ON file_db.cleanup_logs(status);
```

**索引说明**:

- `idx_files_storage_key`: 通过存储路径查询文件（唯一索引）
- `idx_files_uploader_id`: 查询用户上传的文件
- `idx_files_status`: 按状态筛选文件
- `idx_files_status_created`: 部分索引，仅索引未使用文件，优化清理查询
- `idx_file_usages_file_id`: 查询文件的所有使用位置
- `idx_file_usages_usage`: 查询业务实体使用的文件

---

## 数据关系图

### ER 图

```
┌──────────────────────────────────────┐
│         file_db.files                │
│         (文件元数据表)                │
├──────────────────────────────────────┤
│ id (UUID, PK)                        │
│ filename                             │
│ storage_key (UNIQUE)                 │
│ file_type (ENUM)                     │
│ mime_type                            │
│ file_size                            │
│ uploader_id (逻辑FK → users_auth.id) │
│ status (ENUM)                        │
│ created_at                           │
│ updated_at                           │
└────────────┬─────────────────────────┘
             │
             │ 1:N
             ↓
┌──────────────────────────────────────┐
│      file_db.file_usages             │
│      (文件使用关联表)                 │
├──────────────────────────────────────┤
│ id (SERIAL, PK)                      │
│ file_id (UUID, FK)  ─────────────────┘
│ usage_type (post/reply/avatar/...)   │
│ usage_id (业务实体ID)                │
│ created_at                           │
└──────────────────────────────────────┘
            │
            │ 指向业务实体
            ├─ M3: posts.id (usage_type='post')
            ├─ M4: replies.id (usage_type='reply')
            ├─ M2: users_profile.user_id (usage_type='avatar')
            └─ M5: sections.id (usage_type='section_icon')


┌──────────────────────────────────────┐
│      file_db.cleanup_logs            │
│      (清理日志表，独立)               │
├──────────────────────────────────────┤
│ id (SERIAL, PK)                      │
│ cleanup_time                         │
│ files_deleted                        │
│ space_freed                          │
│ duration_ms                          │
│ status                               │
│ error_message                        │
└──────────────────────────────────────┘
```

### 跨服务关联

```
M1 认证授权服务                M7 文件存储服务
┌─────────────────┐           ┌─────────────────┐
│ public.users_auth│           │  file_db.files  │
├─────────────────┤           ├─────────────────┤
│ id (SERIAL, PK) │ 1:N       │ id (UUID, PK)   │
│ username        │ ←─────────│ uploader_id     │
│ password_hash   │ (逻辑外键) │ filename        │
└─────────────────┘           │ storage_key     │
                              └─────────────────┘
```

---

## 数据约束与验证

### 1. 字段约束

```sql
-- 文件名不能为空
ALTER TABLE file_db.files
ADD CONSTRAINT chk_filename_not_empty CHECK (LENGTH(filename) > 0);

-- 存储路径不能为空
ALTER TABLE file_db.files
ADD CONSTRAINT chk_storage_key_not_empty CHECK (LENGTH(storage_key) > 0);

-- 文件大小必须为正数
ALTER TABLE file_db.files
ADD CONSTRAINT chk_file_size_positive CHECK (file_size > 0);

-- 上传者 ID 必须为正数
ALTER TABLE file_db.files
ADD CONSTRAINT chk_uploader_id_positive CHECK (uploader_id > 0);
```

### 2. 业务约束

#### 文件状态转换规则

```sql
-- 触发器：防止非法状态转换
CREATE OR REPLACE FUNCTION file_db.check_status_transition()
RETURNS TRIGGER AS $$
BEGIN
    -- 已删除的文件不能更改状态
    IF OLD.status = 'deleted' AND NEW.status != 'deleted' THEN
        RAISE EXCEPTION 'Cannot change status of deleted file';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_status_transition
    BEFORE UPDATE ON file_db.files
    FOR EACH ROW
    EXECUTE FUNCTION file_db.check_status_transition();
```

#### 自动更新 updated_at

```sql
-- 触发器：自动更新 updated_at
CREATE OR REPLACE FUNCTION file_db.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_files_updated_at
    BEFORE UPDATE ON file_db.files
    FOR EACH ROW
    EXECUTE FUNCTION file_db.update_updated_at_column();
```

### 3. 引用完整性

由于跨 Schema 不能使用物理外键，使用应用层检查：

```rust
// 在应用层验证 uploader_id
async fn validate_uploader_exists(uploader_id: i32, db: &PgPool) -> Result<()> {
    let exists = sqlx::query_scalar!(
        "SELECT EXISTS(SELECT 1 FROM public.users_auth WHERE id = $1)",
        uploader_id
    )
    .fetch_one(db)
    .await?
    .unwrap_or(false);
    
    if !exists {
        return Err(anyhow!("Uploader user_id {} not found", uploader_id));
    }
    
    Ok(())
}
```

---

## 数据迁移

### 使用 SQLx CLI 管理迁移

#### 1. 初始 Schema 创建

**migrations/20251028_001_initial_schema.sql**:

```sql
-- 创建 Schema
CREATE SCHEMA IF NOT EXISTS file_db;

-- 设置搜索路径
SET search_path TO file_db;

-- 创建枚举类型
CREATE TYPE file_db.file_type AS ENUM ('avatar', 'post', 'reply', 'section_icon');
CREATE TYPE file_db.file_status AS ENUM ('unused', 'used', 'deleted');

-- 创建 files 表
CREATE TABLE file_db.files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    filename VARCHAR(255) NOT NULL,
    storage_key VARCHAR(500) NOT NULL UNIQUE,
    file_type file_db.file_type NOT NULL,
    mime_type VARCHAR(100) NOT NULL,
    file_size BIGINT NOT NULL,
    uploader_id INTEGER NOT NULL,
    status file_db.file_status NOT NULL DEFAULT 'unused',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT chk_filename_not_empty CHECK (LENGTH(filename) > 0),
    CONSTRAINT chk_storage_key_not_empty CHECK (LENGTH(storage_key) > 0),
    CONSTRAINT chk_file_size_positive CHECK (file_size > 0),
    CONSTRAINT chk_uploader_id_positive CHECK (uploader_id > 0)
);

-- 添加注释
COMMENT ON TABLE file_db.files IS '文件元数据表';
-- ... (其他注释)
```

#### 2. 创建关联表

**migrations/20251028_002_file_usages.sql**:

```sql
SET search_path TO file_db;

-- 创建 file_usages 表
CREATE TABLE file_db.file_usages (
    id SERIAL PRIMARY KEY,
    file_id UUID NOT NULL,
    usage_type VARCHAR(20) NOT NULL,
    usage_id INTEGER NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT fk_file FOREIGN KEY (file_id) 
        REFERENCES file_db.files(id) ON DELETE CASCADE,
    CONSTRAINT uk_file_usage UNIQUE (file_id, usage_type, usage_id),
    CONSTRAINT chk_usage_type CHECK (usage_type IN ('post', 'reply', 'avatar', 'section_icon')),
    CONSTRAINT chk_usage_id_positive CHECK (usage_id > 0)
);

COMMENT ON TABLE file_db.file_usages IS '文件使用关联表';
```

#### 3. 创建索引

**migrations/20251028_003_indexes.sql**:

```sql
SET search_path TO file_db;

-- files 表索引
CREATE UNIQUE INDEX idx_files_storage_key ON file_db.files(storage_key);
CREATE INDEX idx_files_uploader_id ON file_db.files(uploader_id);
CREATE INDEX idx_files_status ON file_db.files(status);
CREATE INDEX idx_files_file_type ON file_db.files(file_type);
CREATE INDEX idx_files_created_at ON file_db.files(created_at);
CREATE INDEX idx_files_status_created ON file_db.files(status, created_at) 
    WHERE status = 'unused';

-- file_usages 表索引
CREATE INDEX idx_file_usages_file_id ON file_db.file_usages(file_id);
CREATE INDEX idx_file_usages_usage ON file_db.file_usages(usage_type, usage_id);
```

#### 4. 创建清理日志表

**migrations/20251028_004_cleanup_logs.sql**:

```sql
SET search_path TO file_db;

CREATE TABLE file_db.cleanup_logs (
    id SERIAL PRIMARY KEY,
    cleanup_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    files_deleted INTEGER NOT NULL DEFAULT 0,
    space_freed BIGINT NOT NULL DEFAULT 0,
    duration_ms INTEGER,
    status VARCHAR(20) NOT NULL DEFAULT 'success',
    error_message TEXT,
    
    CONSTRAINT chk_files_deleted_positive CHECK (files_deleted >= 0),
    CONSTRAINT chk_space_freed_positive CHECK (space_freed >= 0),
    CONSTRAINT chk_status CHECK (status IN ('success', 'partial', 'failed'))
);

CREATE INDEX idx_cleanup_logs_time ON file_db.cleanup_logs(cleanup_time DESC);
CREATE INDEX idx_cleanup_logs_status ON file_db.cleanup_logs(status);

COMMENT ON TABLE file_db.cleanup_logs IS '自动清理日志表';
```

#### 5. 创建触发器

**migrations/20251028_005_triggers.sql**:

```sql
SET search_path TO file_db;

-- 自动更新 updated_at
CREATE OR REPLACE FUNCTION file_db.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_files_updated_at
    BEFORE UPDATE ON file_db.files
    FOR EACH ROW
    EXECUTE FUNCTION file_db.update_updated_at_column();

-- 状态转换检查
CREATE OR REPLACE FUNCTION file_db.check_status_transition()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.status = 'deleted' AND NEW.status != 'deleted' THEN
        RAISE EXCEPTION 'Cannot change status of deleted file';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_check_status_transition
    BEFORE UPDATE ON file_db.files
    FOR EACH ROW
    EXECUTE FUNCTION file_db.check_status_transition();
```

### 执行迁移

```bash
# 运行所有迁移
sqlx migrate run

# 查看迁移状态
sqlx migrate info

# 回滚最后一次迁移
sqlx migrate revert
```

---

## 性能优化

### 1. 查询优化

#### 查询未使用且超过 30 天的文件（清理任务）

```sql
-- 使用部分索引 idx_files_status_created
SELECT id, storage_key, file_size
FROM file_db.files
WHERE status = 'unused'
  AND created_at < CURRENT_TIMESTAMP - INTERVAL '30 days'
ORDER BY created_at
LIMIT 100;
```

**EXPLAIN ANALYZE**:

```
Index Scan using idx_files_status_created on files
  Index Cond: ((status = 'unused') AND (created_at < ...))
  Rows: 15  Width: 48  Cost: 0.15..8.42
```

#### 查询文件的所有使用位置

```sql
-- 使用索引 idx_file_usages_file_id
SELECT usage_type, usage_id, created_at
FROM file_db.file_usages
WHERE file_id = 'a1b2c3d4-e5f6-4789-a1b2-c3d4e5f67890';
```

### 2. 分区表（可选，数据量大时）

```sql
-- 按 created_at 年份分区
CREATE TABLE file_db.files_partitioned (
    LIKE file_db.files INCLUDING ALL
) PARTITION BY RANGE (created_at);

-- 创建分区
CREATE TABLE file_db.files_2025 PARTITION OF file_db.files_partitioned
    FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');

CREATE TABLE file_db.files_2026 PARTITION OF file_db.files_partitioned
    FOR VALUES FROM ('2026-01-01') TO ('2027-01-01');
```

### 3. 连接池配置

```rust
use sqlx::postgres::PgPoolOptions;

let pool = PgPoolOptions::new()
    .max_connections(20)       // 最大连接数
    .min_connections(5)        // 最小连接数
    .acquire_timeout(Duration::from_secs(5))
    .idle_timeout(Duration::from_secs(600))
    .connect(&database_url)
    .await?;
```

### 4. 定期维护

```sql
-- 更新统计信息
ANALYZE file_db.files;
ANALYZE file_db.file_usages;

-- 清理死元组
VACUUM ANALYZE file_db.files;
VACUUM ANALYZE file_db.file_usages;

-- 重建索引（可选）
REINDEX TABLE file_db.files;
```

---

## 监控与统计

### 1. 存储统计查询

```sql
-- 总文件数和占用空间
SELECT 
    COUNT(*) as total_files,
    SUM(file_size) as total_size,
    pg_size_pretty(SUM(file_size)::bigint) as total_size_pretty
FROM file_db.files
WHERE status != 'deleted';

-- 按类型统计
SELECT 
    file_type,
    COUNT(*) as file_count,
    pg_size_pretty(SUM(file_size)::bigint) as total_size
FROM file_db.files
WHERE status != 'deleted'
GROUP BY file_type
ORDER BY SUM(file_size) DESC;

-- 按状态统计
SELECT 
    status,
    COUNT(*) as file_count,
    pg_size_pretty(SUM(file_size)::bigint) as total_size
FROM file_db.files
GROUP BY status;
```

### 2. 表大小监控

```sql
-- 查看表大小
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size
FROM pg_tables
WHERE schemaname = 'file_db'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

### 3. 索引使用情况

```sql
-- 查看索引使用统计
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'file_db'
ORDER BY idx_scan DESC;
```

---

**文档版本**: v1.0  
**创建日期**: 2025-10-28  
**最后更新**: 2025-10-28


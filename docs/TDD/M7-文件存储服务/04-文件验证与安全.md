# M7 文件存储服务 - 文件验证与安全

## 文档信息

**服务名称**: 文件存储服务 (file-service)  
**安全等级**: 高  
**验证策略**: 多层验证（扩展名 + MIME + 魔数）  
**版本**: v1.0

---

## 目录

1. [安全概述](#安全概述)
2. [文件类型验证](#文件类型验证)
3. [文件大小限制](#文件大小限制)
4. [文件名安全](#文件名安全)
5. [路径安全](#路径安全)
6. [身份认证](#身份认证)
7. [错误处理](#错误处理)
8. [安全最佳实践](#安全最佳实践)

---

## 安全概述

### 安全威胁

| 威胁类型       | 描述                                   | 防护措施               |
| -------------- | -------------------------------------- | ---------------------- |
| **文件伪装**   | 恶意文件伪装成图片（如 exe → jpg）     | 魔数验证               |
| **路径遍历**   | 通过 `../` 访问系统文件                | 路径清理和验证         |
| **超大文件**   | 上传超大文件耗尽存储空间               | 大小限制               |
| **未授权访问** | 未登录用户上传文件                     | JWT 认证（Kong 网关）  |
| **恶意文件名** | 文件名包含特殊字符（如 `..`, `/`, `\`）| 文件名清理             |

### 安全层次

```
┌──────────────────────────────────┐
│     Kong 网关 JWT 验证            │  ← 第 1 层：身份认证
├──────────────────────────────────┤
│     文件大小验证                  │  ← 第 2 层：大小限制
├──────────────────────────────────┤
│     文件名清理                    │  ← 第 3 层：文件名安全
├──────────────────────────────────┤
│     MIME 类型验证                 │  ← 第 4 层：MIME 检查
├──────────────────────────────────┤
│     文件魔数验证                  │  ← 第 5 层：真实类型检测
├──────────────────────────────────┤
│     路径清理和验证                │  ← 第 6 层：路径安全
└──────────────────────────────────┘
```

---

## 文件类型验证

### 支持的文件类型

| 文件类型 | 扩展名          | MIME 类型                     | 魔数（前 8 字节）                |
| -------- | --------------- | ----------------------------- | -------------------------------- |
| **JPEG** | `.jpg`, `.jpeg` | `image/jpeg`                  | `FF D8 FF`                       |
| **PNG**  | `.png`          | `image/png`                   | `89 50 4E 47 0D 0A 1A 0A`        |
| **GIF**  | `.gif`          | `image/gif`                   | `47 49 46 38` (GIF87a/GIF89a)    |
| **SVG**  | `.svg`          | `image/svg+xml`               | `3C 73 76 67` (`<svg`)           |

### 验证器实现

```rust
// src/utils/validator.rs
use anyhow::{anyhow, Result};
use infer::Type;
use crate::models::enums::FileType;

/// 文件验证器
pub struct FileValidator;

impl FileValidator {
    /// 验证文件类型（魔数验证）
    pub fn validate_file_type(data: &[u8]) -> Result<String> {
        // 使用 infer 库检测文件真实类型
        let kind = infer::get(data)
            .ok_or_else(|| anyhow!("Unable to detect file type"))?;

        // 检查是否为支持的图片类型
        match kind.mime_type() {
            "image/jpeg" | "image/png" | "image/gif" => Ok(kind.mime_type().to_string()),
            "image/svg+xml" | "text/xml" => {
                // SVG 特殊处理（可能被识别为 text/xml）
                if Self::is_svg(data) {
                    Ok("image/svg+xml".to_string())
                } else {
                    Err(anyhow!("Unsupported file type: {}", kind.mime_type()))
                }
            }
            _ => Err(anyhow!("Unsupported file type: {}", kind.mime_type())),
        }
    }

    /// 检查是否为 SVG
    fn is_svg(data: &[u8]) -> bool {
        // 检查文件开头是否包含 <svg 标签
        let content = String::from_utf8_lossy(data);
        content.trim_start().starts_with("<svg") || content.contains("<svg")
    }

    /// 验证 MIME 类型与文件类型匹配
    pub fn validate_mime_type(mime_type: &str, file_type: FileType) -> Result<()> {
        let allowed_types = match file_type {
            FileType::Avatar | FileType::Post | FileType::Reply | FileType::SectionIcon => {
                vec!["image/jpeg", "image/png", "image/gif", "image/svg+xml"]
            }
        };

        if allowed_types.contains(&mime_type) {
            Ok(())
        } else {
            Err(anyhow!(
                "Invalid MIME type '{}' for file type {:?}",
                mime_type,
                file_type
            ))
        }
    }

    /// 验证文件扩展名
    pub fn validate_extension(filename: &str) -> Result<String> {
        let path = std::path::Path::new(filename);
        let ext = path
            .extension()
            .and_then(|e| e.to_str())
            .ok_or_else(|| anyhow!("File has no extension"))?
            .to_lowercase();

        match ext.as_str() {
            "jpg" | "jpeg" | "png" | "gif" | "svg" => Ok(ext),
            _ => Err(anyhow!("Unsupported file extension: {}", ext)),
        }
    }
}
```

### 使用示例

```rust
use actix_multipart::Field;
use futures_util::StreamExt;

async fn validate_upload(mut field: Field) -> Result<(Vec<u8>, String)> {
    // 1. 读取文件数据
    let mut data = Vec::new();
    while let Some(chunk) = field.next().await {
        data.extend_from_slice(&chunk?);
    }

    // 2. 验证文件大小（先验证大小，避免读取超大文件）
    if data.len() > 5 * 1024 * 1024 {  // 5 MB
        return Err(anyhow!("File too large"));
    }

    // 3. 验证文件类型（魔数验证）
    let mime_type = FileValidator::validate_file_type(&data)?;

    // 4. 返回数据和 MIME 类型
    Ok((data, mime_type))
}
```

---

## 文件大小限制

### 大小限制规则

| 文件类型         | 最大大小 | 字节数    | 说明                 |
| ---------------- | -------- | --------- | -------------------- |
| `avatar`         | 2 MB     | 2,097,152 | 头像通常较小         |
| `post`           | 5 MB     | 5,242,880 | 帖子图片可能较大     |
| `reply`          | 5 MB     | 5,242,880 | 回复图片可能较大     |
| `section_icon`   | 500 KB   | 512,000   | 板块图标应该很小     |

### 验证器实现

```rust
impl FileValidator {
    /// 获取文件类型的大小限制（字节）
    pub fn get_size_limit(file_type: FileType) -> usize {
        match file_type {
            FileType::Avatar => 2 * 1024 * 1024,      // 2 MB
            FileType::Post => 5 * 1024 * 1024,        // 5 MB
            FileType::Reply => 5 * 1024 * 1024,       // 5 MB
            FileType::SectionIcon => 500 * 1024,      // 500 KB
        }
    }

    /// 验证文件大小
    pub fn validate_file_size(data: &[u8], file_type: FileType) -> Result<()> {
        let size = data.len();
        let limit = Self::get_size_limit(file_type);

        if size > limit {
            return Err(anyhow!(
                "File too large: {} bytes (max: {} bytes for {:?})",
                size,
                limit,
                file_type
            ));
        }

        if size == 0 {
            return Err(anyhow!("File is empty"));
        }

        Ok(())
    }
}
```

### Actix-web 配置

```rust
use actix_web::web::PayloadConfig;

App::new()
    // 设置全局最大请求体大小为 10 MB
    .app_data(PayloadConfig::new(10 * 1024 * 1024))
    .configure(handlers::configure_routes)
```

---

## 文件名安全

### 文件名威胁

| 威胁                 | 示例                          | 风险               |
| -------------------- | ----------------------------- | ------------------ |
| **路径遍历**         | `../../etc/passwd`            | 访问系统文件       |
| **特殊字符**         | `file<script>.jpg`            | XSS 攻击           |
| **空字节注入**       | `file.jpg\0.php`              | 绕过扩展名检查     |
| **超长文件名**       | 255+ 字符的文件名             | 文件系统错误       |
| **Unicode 欺骗**     | `file‮gpj.exe`（反向字符）    | 伪装文件类型       |

### 文件名清理

```rust
// src/utils/path_generator.rs
use uuid::Uuid;
use chrono::{Utc, Datelike};
use std::path::Path;

/// 文件路径生成器
pub struct PathGenerator;

impl PathGenerator {
    /// 生成安全的存储路径
    /// 格式: YYYY/MM/DD/uuid.ext
    pub fn generate_storage_key(original_filename: &str) -> Result<String> {
        // 1. 提取扩展名
        let ext = Path::new(original_filename)
            .extension()
            .and_then(|e| e.to_str())
            .ok_or_else(|| anyhow!("Invalid filename"))?
            .to_lowercase();

        // 2. 验证扩展名
        if !["jpg", "jpeg", "png", "gif", "svg"].contains(&ext.as_str()) {
            return Err(anyhow!("Invalid file extension: {}", ext));
        }

        // 3. 生成 UUID 文件名
        let uuid = Uuid::new_v4();
        let filename = format!("{}.{}", uuid, ext);

        // 4. 按日期分目录（YYYY/MM/DD）
        let now = Utc::now();
        let year = now.year();
        let month = now.month();
        let day = now.day();

        let storage_key = format!("{:04}/{:02}/{:02}/{}", year, month, day, filename);

        Ok(storage_key)
    }

    /// 清理原始文件名（用于保存到数据库）
    pub fn sanitize_filename(filename: &str) -> String {
        filename
            .chars()
            .filter(|c| c.is_alphanumeric() || *c == '.' || *c == '-' || *c == '_')
            .take(255)  // 限制长度
            .collect()
    }

    /// 验证存储路径不包含危险字符
    pub fn validate_storage_key(key: &str) -> Result<()> {
        // 检查路径遍历
        if key.contains("..") {
            return Err(anyhow!("Path traversal detected"));
        }

        // 检查绝对路径
        if key.starts_with('/') || key.starts_with('\\') {
            return Err(anyhow!("Absolute path not allowed"));
        }

        // 检查 Windows 驱动器路径
        if key.len() >= 2 && key.chars().nth(1) == Some(':') {
            return Err(anyhow!("Windows drive path not allowed"));
        }

        Ok(())
    }
}
```

### 使用示例

```rust
// 生成安全的存储路径
let storage_key = PathGenerator::generate_storage_key("my photo.jpg")?;
// 结果: 2025/10/28/a1b2c3d4-e5f6-4789-a1b2-c3d4e5f67890.jpg

// 清理原始文件名
let safe_filename = PathGenerator::sanitize_filename("my<script>photo.jpg");
// 结果: myscriptphoto.jpg
```

---

## 路径安全

### 路径验证

```rust
impl PathGenerator {
    /// 验证路径安全性
    pub fn is_safe_path(path: &str) -> bool {
        // 禁止的模式
        let forbidden = [
            "..",           // 父目录
            "//",           // 多重斜杠
            "\\\\",         // Windows 路径
            "\0",           // 空字节
            "|", "&", ";",  // Shell 命令
        ];

        for pattern in &forbidden {
            if path.contains(pattern) {
                return false;
            }
        }

        // 路径必须是相对路径
        if path.starts_with('/') || path.starts_with('\\') {
            return false;
        }

        // Windows 驱动器路径检查
        if path.len() >= 2 {
            let chars: Vec<char> = path.chars().collect();
            if chars[1] == ':' {
                return false;
            }
        }

        true
    }
}
```

### 测试用例

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_path_safety() {
        // 安全路径
        assert!(PathGenerator::is_safe_path("2025/10/28/file.jpg"));

        // 危险路径
        assert!(!PathGenerator::is_safe_path("../../../etc/passwd"));
        assert!(!PathGenerator::is_safe_path("/etc/passwd"));
        assert!(!PathGenerator::is_safe_path("C:\\Windows\\System32"));
        assert!(!PathGenerator::is_safe_path("file|rm -rf /"));
    }
}
```

---

## 身份认证

### Kong 网关 JWT 验证

```
┌──────────────┐      JWT Token      ┌──────────────┐
│   客户端     │ ───────────────────→ │  Kong 网关   │
│             │                      │             │
└──────────────┘                      └──────┬───────┘
                                            │
                                    验证 JWT（M1 服务）
                                            │
                                     ┌──────▼───────┐
                                     │   M7 文件    │
                                     │   存储服务   │
                                     └──────────────┘
```

**流程**:

1. 客户端在请求头中携带 JWT Token
2. Kong 网关拦截请求，调用 M1 服务验证 Token
3. 验证通过后，Kong 转发请求到 M7，并附加用户信息
4. M7 从请求头中获取用户 ID（`X-User-Id`）

### Actix-web 中间件

```rust
// src/middleware/auth.rs
use actix_web::{
    dev::{ServiceRequest, ServiceResponse},
    Error, HttpMessage,
};
use actix_web::middleware::Next;

/// 从 Kong 网关传递的用户 ID
pub async fn extract_user_id(
    req: ServiceRequest,
    next: Next<impl actix_web::body::MessageBody>,
) -> Result<ServiceResponse<impl actix_web::body::MessageBody>, Error> {
    // Kong 网关会在请求头中添加 X-User-Id
    let user_id = req
        .headers()
        .get("X-User-Id")
        .and_then(|v| v.to_str().ok())
        .and_then(|s| s.parse::<i32>().ok());

    if let Some(uid) = user_id {
        req.extensions_mut().insert(uid);
    }

    next.call(req).await
}

/// 获取当前用户 ID
pub fn get_current_user_id(req: &HttpRequest) -> Result<i32> {
    req.extensions()
        .get::<i32>()
        .copied()
        .ok_or_else(|| anyhow!("User not authenticated"))
}
```

### 在 Handler 中使用

```rust
use actix_web::{web, HttpRequest, HttpResponse};

pub async fn upload_handler(
    req: HttpRequest,
    payload: web::Payload,
) -> Result<HttpResponse> {
    // 获取当前用户 ID
    let user_id = crate::middleware::auth::get_current_user_id(&req)?;

    // 处理上传逻辑
    // ...

    Ok(HttpResponse::Ok().finish())
}
```

---

## 错误处理

### 错误类型定义

```rust
// src/utils/error.rs
use thiserror::Error;
use actix_web::{http::StatusCode, HttpResponse, ResponseError};

#[derive(Error, Debug)]
pub enum FileError {
    #[error("File type not supported: {0}")]
    UnsupportedFileType(String),

    #[error("File too large: {size} bytes (max: {max} bytes)")]
    FileTooLarge { size: usize, max: usize },

    #[error("Invalid file name: {0}")]
    InvalidFileName(String),

    #[error("Path traversal detected")]
    PathTraversal,

    #[error("File not found: {0}")]
    FileNotFound(String),

    #[error("Authentication required")]
    Unauthorized,
}

impl ResponseError for FileError {
    fn status_code(&self) -> StatusCode {
        match self {
            Self::UnsupportedFileType(_) => StatusCode::BAD_REQUEST,
            Self::FileTooLarge { .. } => StatusCode::PAYLOAD_TOO_LARGE,
            Self::InvalidFileName(_) => StatusCode::BAD_REQUEST,
            Self::PathTraversal => StatusCode::FORBIDDEN,
            Self::FileNotFound(_) => StatusCode::NOT_FOUND,
            Self::Unauthorized => StatusCode::UNAUTHORIZED,
        }
    }

    fn error_response(&self) -> HttpResponse {
        HttpResponse::build(self.status_code()).json(json!({
            "code": self.status_code().as_u16(),
            "message": self.to_string(),
        }))
    }
}
```

### 错误码定义

| 错误码   | HTTP 状态码 | 说明                   |
| -------- | ----------- | ---------------------- |
| 70000001 | 400         | 文件类型不支持         |
| 70000002 | 413         | 文件过大               |
| 70000003 | 400         | 文件名非法             |
| 70000004 | 403         | 路径遍历攻击           |
| 70000005 | 400         | 文件为空               |
| 70000006 | 401         | 未认证                 |
| 70000007 | 404         | 文件不存在             |

---

## 安全最佳实践

### 1. 输入验证

```rust
// ✅ 多层验证
pub async fn validate_upload(
    data: &[u8],
    filename: &str,
    file_type: FileType,
) -> Result<()> {
    // 1. 验证文件大小
    FileValidator::validate_file_size(data, file_type)?;

    // 2. 验证文件扩展名
    FileValidator::validate_extension(filename)?;

    // 3. 验证文件魔数
    let mime_type = FileValidator::validate_file_type(data)?;

    // 4. 验证 MIME 与文件类型匹配
    FileValidator::validate_mime_type(&mime_type, file_type)?;

    Ok(())
}
```

### 2. 使用 UUID 文件名

```rust
// ✅ 使用 UUID，避免文件名冲突和路径遍历
let storage_key = PathGenerator::generate_storage_key(filename)?;
// 结果: 2025/10/28/a1b2c3d4-e5f6-4789-a1b2-c3d4e5f67890.jpg
```

### 3. 限制文件访问

```rust
// ✅ 所有文件公开访问，但删除后立即失效
// 通过 Kong 网关控制上传权限
```

### 4. 定期安全审计

```sql
-- 查询异常大的文件
SELECT id, filename, file_size, uploader_id
FROM file_db.files
WHERE file_size > 10 * 1024 * 1024  -- 10 MB
ORDER BY file_size DESC;

-- 查询上传频率异常的用户
SELECT uploader_id, COUNT(*) as upload_count
FROM file_db.files
WHERE created_at > NOW() - INTERVAL '1 hour'
GROUP BY uploader_id
HAVING COUNT(*) > 100
ORDER BY upload_count DESC;
```

### 5. 日志记录

```rust
use tracing::{info, warn, error};

#[tracing::instrument]
pub async fn upload_file(
    user_id: i32,
    filename: &str,
    data: &[u8],
) -> Result<String> {
    info!(
        user_id = user_id,
        filename = filename,
        size = data.len(),
        "File upload started"
    );

    // 验证逻辑
    if let Err(e) = validate_upload(data, filename, file_type) {
        warn!(
            user_id = user_id,
            filename = filename,
            error = %e,
            "File validation failed"
        );
        return Err(e);
    }

    // 上传逻辑
    // ...

    info!(
        user_id = user_id,
        storage_key = storage_key,
        "File uploaded successfully"
    );

    Ok(url)
}
```

---

## 安全检查清单

### 上传前检查

- [ ] 验证用户身份（JWT Token）
- [ ] 验证文件大小（根据文件类型）
- [ ] 验证文件扩展名
- [ ] 验证 MIME 类型
- [ ] 验证文件魔数（真实类型）

### 存储前检查

- [ ] 清理文件名（移除特殊字符）
- [ ] 生成 UUID 文件名
- [ ] 验证存储路径安全性
- [ ] 按日期分目录存储

### 访问前检查

- [ ] 验证文件是否存在
- [ ] 验证文件状态（未删除）
- [ ] 记录访问日志

### 定期检查

- [ ] 审计异常大的文件
- [ ] 审计上传频率异常的用户
- [ ] 检查未使用文件并清理
- [ ] 备份文件元数据

---

**文档版本**: v1.0  
**创建日期**: 2025-10-28  
**最后更新**: 2025-10-28


# M5 板块管理服务 - 与其他服务集成

## 文档信息

**服务名称**: 板块管理服务 (section-service)  
**技术栈**: Python 3.11+ + Django 4.2+  
**版本**: v1.0

---

## 目录

1. [集成架构概述](#集成架构概述)
2. [与 M1 认证服务集成](#与-m1-认证服务集成)
3. [与 M3 内容服务集成](#与-m3-内容服务集成)
4. [与 M7 文件服务集成](#与-m7-文件服务集成)
5. [Consul 服务注册](#consul-服务注册)
6. [错误处理与重试](#错误处理与重试)

---

## 集成架构概述

### 服务依赖关系

```
M5 板块管理服务
├── 依赖 M1 认证服务
│   └── Token 验证
│   └── 管理员权限验证
├── 依赖 M7 文件服务
│   └── 上传板块图标
│   └── 获取图标 URL
└── 被 M3 内容服务依赖
    └── 验证板块有效性
    └── 更新板块帖子数
```

### 通信方式

- **服务发现**: Consul
- **通信协议**: HTTP/RESTful API
- **认证方式**: Sa-Token
- **数据格式**: JSON

---

## 与 M1 认证服务集成

### 1. Token 验证

M5 的管理员接口需要验证用户是否为管理员，通过调用 M1 的 Token 验证接口实现。

#### 集成流程

```
1. 客户端请求 M5 管理接口
   ↓
2. M5 提取 Token
   ↓
3. M5 调用 M1 验证 Token
   POST /api/auth/verify
   ↓
4. M1 返回用户信息和角色
   ↓
5. M5 验证角色是否为 admin
   ↓
6. 允许/拒绝请求
```

#### AuthServiceClient 实现

**apps/core/service_client.py**:

```python
import requests
from django.conf import settings
from .consul_client import ConsulClient


class AuthServiceClient:
    """
    M1 认证服务客户端
    """
    
    def __init__(self):
        self.consul_client = ConsulClient()
        self.service_name = settings.AUTH_SERVICE_NAME
    
    def _get_service_url(self):
        """
        从 Consul 获取认证服务地址
        """
        service_info = self.consul_client.get_service(self.service_name)
        if not service_info:
            raise Exception(f'Service {self.service_name} not found in Consul')
        
        # 选择第一个健康的实例
        return f"http://{service_info['address']}:{service_info['port']}"
    
    def verify_token(self, token):
        """
        验证 Token
        
        Args:
            token: Sa-Token 字符串
        
        Returns:
            dict: {
                'valid': True/False,
                'userId': 1,
                'username': 'admin',
                'role': 'admin'
            }
        
        Raises:
            Exception: 当验证失败时
        """
        service_url = self._get_service_url()
        url = f"{service_url}/api/auth/verify"
        
        try:
            response = requests.post(
                url,
                headers={'Authorization': f'Bearer {token}'},
                timeout=5
            )
            
            if response.status_code == 200:
                data = response.json().get('data', {})
                return {
                    'valid': True,
                    'userId': data.get('userId'),
                    'username': data.get('username'),
                    'role': data.get('role', 'user')
                }
            else:
                return {'valid': False}
        
        except requests.exceptions.Timeout:
            raise Exception('Auth service timeout')
        except requests.exceptions.RequestException as e:
            raise Exception(f'Auth service error: {str(e)}')
```

#### Token 验证中间件

**apps/core/middleware.py**:

```python
from django.utils.deprecation import MiddlewareMixin
from django.http import JsonResponse
from .service_client import AuthServiceClient
import logging

logger = logging.getLogger(__name__)


class TokenAuthMiddleware(MiddlewareMixin):
    """
    Token 验证中间件
    """
    
    # 不需要认证的路径
    SKIP_PATHS = [
        '/api/sections',           # 公开接口（GET）
        '/health/',                # 健康检查
        '/internal/',              # 内部接口
        '/api/docs/',              # API 文档
        '/api/schema/',            # OpenAPI Schema
    ]
    
    def process_request(self, request):
        """
        验证请求中的 Token
        """
        # 跳过不需要认证的路径
        if self._should_skip(request):
            return None
        
        # 提取 Token
        auth_header = request.META.get('HTTP_AUTHORIZATION', '')
        
        if not auth_header.startswith('Bearer '):
            return JsonResponse({
                'code': 401,
                'message': '缺少认证 Token',
                'error': 'Unauthorized'
            }, status=401)
        
        token = auth_header.replace('Bearer ', '').strip()
        
        # 调用 M1 认证服务验证 Token
        try:
            auth_client = AuthServiceClient()
            result = auth_client.verify_token(token)
            
            if result['valid']:
                # 将用户信息附加到 request
                request.user_id = result['userId']
                request.username = result['username']
                request.user_role = result['role']
                request.user_token = token
                
                logger.info(f"User {request.username} authenticated successfully")
            else:
                return JsonResponse({
                    'code': 401,
                    'message': 'Token 无效或已过期',
                    'error': 'Unauthorized'
                }, status=401)
        
        except Exception as e:
            logger.error(f"Token verification failed: {str(e)}")
            return JsonResponse({
                'code': 500,
                'message': f'Token 验证失败: {str(e)}',
                'error': 'InternalError'
            }, status=500)
        
        return None
    
    def _should_skip(self, request):
        """
        判断是否跳过认证
        """
        path = request.path
        
        # 检查是否在跳过列表中
        for skip_path in self.SKIP_PATHS:
            if path.startswith(skip_path):
                # 公开接口仅允许 GET 请求
                if path.startswith('/api/sections') and request.method == 'GET':
                    return True
                elif not path.startswith('/api/sections'):
                    return True
        
        return False
```

### 2. 权限验证

**apps/core/permissions.py**:

```python
from rest_framework.permissions import BasePermission


class IsAdminUser(BasePermission):
    """
    验证用户是否为管理员
    """
    
    message = '需要管理员权限'
    
    def has_permission(self, request, view):
        """
        检查用户角色
        """
        user_role = getattr(request, 'user_role', None)
        return user_role == 'admin'
```

### 3. 使用示例

```python
from rest_framework.decorators import action
from rest_framework.permissions import IsAuthenticated
from apps.core.permissions import IsAdminUser


class SectionViewSet(viewsets.ModelViewSet):
    """
    板块视图集
    """
    
    def get_permissions(self):
        """
        根据操作设置权限
        """
        if self.action in ['list', 'retrieve']:
            # 公开接口
            return [AllowAny()]
        else:
            # 管理员接口
            return [IsAuthenticated(), IsAdminUser()]
    
    @action(detail=False, methods=['post'], 
            permission_classes=[IsAuthenticated, IsAdminUser])
    def create_section(self, request):
        """
        创建板块（仅管理员）
        """
        # request.user_id - 用户 ID
        # request.username - 用户名
        # request.user_role - 用户角色
        pass
```

---

## 与 M3 内容服务集成

### 1. M3 验证板块有效性

当用户在 M3 创建帖子时，M3 需要验证板块是否启用。

#### M3 调用 M5

```python
# M3 内容服务代码
import requests

def validate_section(section_slug):
    """
    验证板块是否有效
    
    Args:
        section_slug: 板块标识
    
    Returns:
        dict: 板块信息 or None
    """
    # 通过 Consul 获取 M5 服务地址
    section_service_url = get_service_url('section-service')
    
    try:
        response = requests.get(
            f"{section_service_url}/api/sections/{section_slug}",
            timeout=5
        )
        
        if response.status_code == 200:
            section = response.json().get('data')
            
            # 检查板块是否启用
            if section.get('is_enabled'):
                return section
            else:
                raise ValueError('板块已禁用')
        else:
            raise ValueError('板块不存在')
    
    except requests.exceptions.RequestException as e:
        raise Exception(f'Section service error: {str(e)}')
```

#### M5 提供的接口

```
GET /api/sections/{slug}

Response:
{
    "code": 200,
    "message": "success",
    "data": {
        "id": 1,
        "slug": "tech",
        "name": "技术交流",
        "is_enabled": true
    }
}
```

### 2. M3 更新板块帖子数

当 M3 创建或删除帖子时，需要更新 M5 的板块帖子数。

#### M3 调用 M5 内部接口

```python
# M3 创建帖子后调用
def increment_section_posts(section_id, value=1):
    """
    更新板块帖子数
    
    Args:
        section_id: 板块 ID
        value: 增量（+1 创建，-1 删除）
    """
    section_service_url = get_service_url('section-service')
    
    try:
        response = requests.post(
            f"{section_service_url}/internal/sections/{section_id}/increment-posts",
            json={'value': value},
            timeout=5
        )
        
        if response.status_code == 200:
            return response.json().get('data')
        else:
            # 记录错误但不阻塞
            logger.error(f'Failed to update section posts count: {response.text}')
    
    except requests.exceptions.RequestException as e:
        # 记录错误但不阻塞
        logger.error(f'Section service error: {str(e)}')
```

#### M5 内部接口实现

**apps/sections/views.py**:

```python
from rest_framework import viewsets
from rest_framework.decorators import action
from django.shortcuts import get_object_or_404
from .models import Section


class InternalSectionViewSet(viewsets.ViewSet):
    """
    内部接口视图集（供其他服务调用）
    """
    
    permission_classes = []  # 内部接口不需要认证
    
    @action(detail=True, methods=['post'])
    def increment_posts(self, request, pk=None):
        """
        更新板块帖子数
        
        POST /internal/sections/{id}/increment-posts
        Body: {"value": 1}  # +1 或 -1
        """
        section = get_object_or_404(Section, id=pk)
        
        value = request.data.get('value', 1)
        
        # 验证 value
        if not isinstance(value, int) or value not in [-1, 1]:
            return Response({
                'code': 400,
                'message': 'value 必须是 1 或 -1'
            }, status=400)
        
        # 更新帖子数
        section.increment_posts_count(value)
        
        return Response({
            'code': 200,
            'message': 'success',
            'data': {
                'id': section.id,
                'posts_count': section.posts_count
            }
        })
```

### 3. 完整集成流程

```
M3 创建帖子流程:

1. 用户选择板块（slug: "tech"）
   ↓
2. M3 验证板块是否启用
   GET http://section-service:8005/api/sections/tech
   ↓
3. M5 返回板块信息
   {"id": 1, "slug": "tech", "is_enabled": true}
   ↓
4. M3 创建帖子记录
   INSERT INTO posts (section_id, ...) VALUES (1, ...)
   ↓
5. M3 通知 M5 更新帖子数
   POST http://section-service:8005/internal/sections/1/increment-posts
   Body: {"value": 1}
   ↓
6. M5 更新板块帖子数
   UPDATE sections SET posts_count = posts_count + 1 WHERE id = 1
```

---

## 与 M7 文件服务集成

### 1. 上传板块图标

管理员创建或编辑板块时，可以上传板块图标。

#### 集成流程

```
1. 管理员上传图标文件
   ↓
2. 前端调用 M7 上传接口
   POST /api/files/upload
   Content-Type: multipart/form-data
   file_type: section_icon
   ↓
3. M7 返回 file_id
   {"file_id": "uuid", "url": "..."}
   ↓
4. 前端调用 M5 创建板块
   POST /api/sections
   {
     "icon_file_id": "uuid",
     ...
   }
   ↓
5. M5 保存板块信息
```

#### FileServiceClient 实现

**apps/core/service_client.py**:

```python
class FileServiceClient:
    """
    M7 文件服务客户端
    """
    
    def __init__(self):
        self.consul_client = ConsulClient()
        self.service_name = settings.FILE_SERVICE_NAME
    
    def _get_service_url(self):
        """
        从 Consul 获取文件服务地址
        """
        service_info = self.consul_client.get_service(self.service_name)
        if not service_info:
            raise Exception(f'Service {self.service_name} not found in Consul')
        
        return f"http://{service_info['address']}:{service_info['port']}"
    
    def get_file_url(self, file_id):
        """
        获取文件 URL
        
        Args:
            file_id: 文件 UUID
        
        Returns:
            dict: {'url': '...', 'file_type': '...'}
        """
        service_url = self._get_service_url()
        url = f"{service_url}/api/files/{file_id}/url"
        
        try:
            response = requests.get(url, timeout=5)
            
            if response.status_code == 200:
                return response.json().get('data', {})
            else:
                return None
        
        except requests.exceptions.RequestException as e:
            logger.error(f'File service error: {str(e)}')
            return None
    
    def get_file_info(self, file_id):
        """
        获取文件详细信息
        
        Args:
            file_id: 文件 UUID
        
        Returns:
            dict: 文件信息
        """
        service_url = self._get_service_url()
        url = f"{service_url}/api/files/{file_id}"
        
        try:
            response = requests.get(url, timeout=5)
            
            if response.status_code == 200:
                return response.json().get('data', {})
            else:
                return None
        
        except requests.exceptions.RequestException as e:
            logger.error(f'File service error: {str(e)}')
            return None
```

### 2. 序列化器中获取图标 URL

**apps/sections/serializers.py**:

```python
from rest_framework import serializers
from .models import Section
from apps.core.service_client import FileServiceClient


class SectionListSerializer(serializers.ModelSerializer):
    """
    板块列表序列化器
    """
    
    icon_url = serializers.SerializerMethodField()
    
    class Meta:
        model = Section
        fields = [
            'id', 'slug', 'name', 'description',
            'icon_url', 'color', 'sort_order', 'posts_count'
        ]
    
    def get_icon_url(self, obj):
        """
        从 M7 获取图标 URL
        """
        if not obj.icon_file_id:
            return None
        
        try:
            file_client = FileServiceClient()
            file_info = file_client.get_file_url(obj.icon_file_id)
            return file_info.get('url') if file_info else None
        except Exception as e:
            # 记录错误但不阻塞
            logger.error(f'Failed to get icon URL: {str(e)}')
            return None
```

### 3. 缓存优化

为避免频繁调用 M7 获取图标 URL，可以使用缓存：

```python
from django.core.cache import cache


def get_icon_url(self, obj):
    """
    从 M7 获取图标 URL（带缓存）
    """
    if not obj.icon_file_id:
        return None
    
    # 缓存键
    cache_key = f'file_url:{obj.icon_file_id}'
    
    # 尝试从缓存获取
    cached_url = cache.get(cache_key)
    if cached_url:
        return cached_url
    
    # 调用 M7 获取
    try:
        file_client = FileServiceClient()
        file_info = file_client.get_file_url(obj.icon_file_id)
        url = file_info.get('url') if file_info else None
        
        # 缓存 1 小时
        if url:
            cache.set(cache_key, url, 3600)
        
        return url
    except Exception as e:
        logger.error(f'Failed to get icon URL: {str(e)}')
        return None
```

---

## Consul 服务注册

### 1. Consul 客户端

**apps/core/consul_client.py**:

```python
import consul
from django.conf import settings
import logging

logger = logging.getLogger(__name__)


class ConsulClient:
    """
    Consul 客户端
    """
    
    def __init__(self):
        consul_url = settings.CONSUL_URL
        # 解析 URL
        if consul_url.startswith('http://'):
            host = consul_url.replace('http://', '').split(':')[0]
            port = int(consul_url.split(':')[-1])
        else:
            host = 'localhost'
            port = 8500
        
        self.consul = consul.Consul(host=host, port=port)
    
    def register_service(self, service_id, service_name, port, host='0.0.0.0'):
        """
        注册服务到 Consul
        
        Args:
            service_id: 服务唯一 ID
            service_name: 服务名称
            port: 服务端口
            host: 服务地址
        """
        try:
            self.consul.agent.service.register(
                name=service_name,
                service_id=service_id,
                address=host,
                port=port,
                check=consul.Check.http(
                    f'http://{host}:{port}/health/',
                    interval='10s',
                    timeout='5s'
                )
            )
            logger.info(f'Service {service_id} registered to Consul')
        except Exception as e:
            logger.error(f'Failed to register service: {str(e)}')
    
    def deregister_service(self, service_id):
        """
        注销服务
        
        Args:
            service_id: 服务唯一 ID
        """
        try:
            self.consul.agent.service.deregister(service_id)
            logger.info(f'Service {service_id} deregistered from Consul')
        except Exception as e:
            logger.error(f'Failed to deregister service: {str(e)}')
    
    def get_service(self, service_name):
        """
        获取服务信息
        
        Args:
            service_name: 服务名称
        
        Returns:
            dict: {'address': '...', 'port': ...} or None
        """
        try:
            # 获取健康的服务实例
            _, services = self.consul.health.service(service_name, passing=True)
            
            if services:
                # 返回第一个健康实例
                service = services[0]
                return {
                    'address': service['Service']['Address'],
                    'port': service['Service']['Port']
                }
            else:
                logger.warning(f'No healthy instances found for {service_name}')
                return None
        
        except Exception as e:
            logger.error(f'Failed to get service: {str(e)}')
            return None
```

### 2. Django 启动时注册

**config/apps.py**:

```python
from django.apps import AppConfig
from django.conf import settings


class SectionConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.sections'
    
    def ready(self):
        """
        应用启动时执行
        """
        # 仅在主进程中注册（避免 runserver 的 reload 重复注册）
        import os
        if os.environ.get('RUN_MAIN') == 'true':
            self.register_to_consul()
    
    def register_to_consul(self):
        """
        注册服务到 Consul
        """
        from apps.core.consul_client import ConsulClient
        
        service_id = settings.CONSUL_SERVICE_ID
        service_name = settings.CONSUL_SERVICE_NAME
        port = settings.SERVICE_PORT
        host = settings.SERVICE_HOST
        
        consul_client = ConsulClient()
        consul_client.register_service(service_id, service_name, port, host)
```

### 3. 健康检查端点

**apps/core/views.py**:

```python
from django.http import JsonResponse
from django.db import connection


def health_check(request):
    """
    健康检查端点
    
    GET /health/
    """
    try:
        # 检查数据库连接
        with connection.cursor() as cursor:
            cursor.execute('SELECT 1')
        
        return JsonResponse({
            'status': 'healthy',
            'service': 'section-service'
        })
    except Exception as e:
        return JsonResponse({
            'status': 'unhealthy',
            'error': str(e)
        }, status=500)
```

**apps/core/urls.py**:

```python
from django.urls import path
from .views import health_check

urlpatterns = [
    path('', health_check, name='health'),
]
```

---

## 错误处理与重试

### 1. 重试装饰器

**apps/core/utils.py**:

```python
import time
import functools
import logging

logger = logging.getLogger(__name__)


def retry(max_attempts=3, delay=1, backoff=2, exceptions=(Exception,)):
    """
    重试装饰器
    
    Args:
        max_attempts: 最大尝试次数
        delay: 初始延迟（秒）
        backoff: 延迟倍增因子
        exceptions: 需要重试的异常类型
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            current_delay = delay
            
            for attempt in range(1, max_attempts + 1):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    if attempt == max_attempts:
                        logger.error(f'{func.__name__} failed after {max_attempts} attempts: {str(e)}')
                        raise
                    
                    logger.warning(f'{func.__name__} attempt {attempt} failed: {str(e)}. Retrying in {current_delay}s...')
                    time.sleep(current_delay)
                    current_delay *= backoff
        
        return wrapper
    return decorator
```

### 2. 使用重试

```python
from apps.core.utils import retry
import requests


class AuthServiceClient:
    """
    M1 认证服务客户端
    """
    
    @retry(max_attempts=3, delay=1, exceptions=(requests.exceptions.RequestException,))
    def verify_token(self, token):
        """
        验证 Token（带重试）
        """
        service_url = self._get_service_url()
        url = f"{service_url}/api/auth/verify"
        
        response = requests.post(
            url,
            headers={'Authorization': f'Bearer {token}'},
            timeout=5
        )
        
        if response.status_code == 200:
            data = response.json().get('data', {})
            return {
                'valid': True,
                'userId': data.get('userId'),
                'username': data.get('username'),
                'role': data.get('role', 'user')
            }
        else:
            return {'valid': False}
```

### 3. 超时配置

```python
# config/settings.py

# 服务调用超时配置
SERVICE_TIMEOUT = {
    'connect': 3,  # 连接超时
    'read': 5,     # 读取超时
}

# 重试配置
RETRY_CONFIG = {
    'max_attempts': 3,
    'delay': 1,
    'backoff': 2,
}
```

---

## 总结

### 集成要点

1. **Consul 服务发现**: 所有服务通过 Consul 注册和发现
2. **Token 认证**: M5 通过 M1 验证用户身份和权限
3. **内部接口**: M5 提供内部接口供 M3 更新数据
4. **文件服务集成**: M5 通过 M7 管理板块图标
5. **错误处理**: 完善的重试机制和错误日志

### 集成流程图

```
用户创建板块（带图标）:

1. 用户上传图标
   ↓ M7
2. 获取 file_id
   ↓
3. 创建板块请求
   ↓ M5（Token 验证）
4. M5 调用 M1 验证 Token
   ↓ M1
5. M1 返回用户信息
   ↓ M5
6. 验证管理员权限
   ↓
7. 保存板块信息
   ↓
8. 返回板块详情（含图标 URL）
   ↓ M7
9. M7 返回图标 URL
```

---

**文档版本**: v1.0  
**创建日期**: 2025-11-04  
**最后更新**: 2025-11-04


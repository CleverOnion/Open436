# M1 认证授权服务 - 开发指南

## 文档信息

**服务名称**: 认证授权服务 (auth-service)  
**技术栈**: Java 17 + Spring Boot 3.x + **Sa-Token** + PostgreSQL + Redis  
**认证方案**: Sa-Token 自动续签（单 Token + 自动续期）  
**端口**: 8001  
**版本**: v3.0

---

## 快速开始

### 1. 环境准备

**系统要求**:

- JDK 17+
- Maven 3.8+ 或 Gradle 8+
- PostgreSQL 14+
- Redis 7+
- Docker (可选)

**克隆项目**:

```bash
# 克隆项目
git clone https://github.com/open436/auth-service.git
cd auth-service

# 使用 Maven 构建
mvn clean install

# 或使用 Gradle
gradle build
```

**Maven 依赖** (pom.xml):

```xml
<dependencies>
    <!-- Spring Boot Starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Sa-Token 权限认证，在线文档：https://sa-token.cc -->
    <dependency>
        <groupId>cn.dev33</groupId>
        <artifactId>sa-token-spring-boot3-starter</artifactId>
        <version>1.37.0</version>
    </dependency>

    <!-- Sa-Token 整合 Redis（使用 jackson 序列化方式） -->
    <dependency>
        <groupId>cn.dev33</groupId>
        <artifactId>sa-token-redis-jackson</artifactId>
        <version>1.37.0</version>
    </dependency>

    <!-- Spring Data JPA -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <!-- PostgreSQL Driver -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <scope>runtime</scope>
    </dependency>

    <!-- Redis -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>

    <!-- Spring Security Crypto（用于密码加密） -->
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-crypto</artifactId>
    </dependency>

    <!-- Validation -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <!-- Lombok -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>

    <!-- Test -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### 2. 配置环境变量

项目使用 `application.yml` 配置文件，支持多环境配置（开发、测试、生产）。

#### 环境配置说明

**配置文件**: `src/main/resources/application.yml`

包含四个配置文件：

- **application.yml**: 主配置文件（共用配置）
- **application-dev.yml**: 开发环境
- **application-test.yml**: 测试环境
- **application-prod.yml**: 生产环境

#### 主配置文件 (application.yml):

```yaml
# application.yml (主配置文件)
spring:
  application:
    name: Open436-Auth
  profiles:
    active: dev # 默认使用开发环境

server:
  port: 8001

# Sa-Token 配置（所有环境共用）
sa-token:
  token-name: satoken
  timeout: 2592000
  active-timeout: -1
  is-concurrent: true
  is-share: true
  token-style: uuid
  is-log: false
  auto-renew:
    enabled: true
    timeout: 2592000

# Kong 网关配置
kong:
  gateway:
    url: http://kong:8000

# 安全配置
security:
  max-login-attempts: 5
  account-lock-duration: 3600

# CORS 配置
cors:
  allowed-origins: http://localhost:3000,http://localhost:8080
  allowed-methods: GET,POST,PUT,DELETE,OPTIONS
  allowed-headers: Authorization,Content-Type
  allow-credentials: true
```

#### 开发环境配置 (application-dev.yml):

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/auth_db
    username: open436
    password: open436
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: true

  data:
    redis:
      host: localhost
      port: 6379
      password:
      timeout: 3000ms

logging:
  level:
    com.open436.auth: DEBUG
    cn.dev33.satoken: DEBUG
```

#### 测试环境配置 (application-test.yml):

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/auth_db_test
    username: open436
    password: open436
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false

  data:
    redis:
      host: localhost
      port: 6379
      timeout: 3000ms

logging:
  level:
    com.open436.auth: INFO
```

#### 生产环境配置 (application-prod.yml):

```yaml
spring:
  datasource:
    url: ${DB_URL}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false

  data:
    redis:
      host: ${REDIS_HOST}
      port: ${REDIS_PORT}
      password: ${REDIS_PASSWORD}
      timeout: 3000ms

logging:
  level:
    com.open436.auth: WARN
```

#### 生产环境变量示例

```bash
# 数据库配置
export DB_URL=jdbc:postgresql://db.example.com:5432/auth_db
export DB_USERNAME=auth_user
export DB_PASSWORD=secure_password

# Redis 配置
export REDIS_HOST=redis.example.com
export REDIS_PORT=6379
export REDIS_PASSWORD=redis_password

# 激活生产环境
export SPRING_PROFILES_ACTIVE=prod
```

### 3. 初始化数据库

**创建数据库**:

```bash
# 连接 PostgreSQL
psql -U postgres

# 创建数据库
CREATE DATABASE auth_db;
CREATE USER open436 WITH PASSWORD 'open436';
GRANT ALL PRIVILEGES ON DATABASE auth_db TO open436;
```

**执行迁移**:

```bash
# 运行数据库迁移脚本
npm run migrate up

# 或手动执行 SQL
psql -U open436 -d auth_db -f migrations/001_initial_schema.sql
```

**初始化数据**:

```bash
# 执行初始化脚本（创建角色、权限、管理员账号）
npm run seed

# 或手动执行
psql -U open436 -d auth_db -f seeds/001_initial_data.sql
```

### 4. 启动服务

```bash
# 使用 Maven 启动
mvn spring-boot:run

# 或者直接运行 JAR
java -jar target/auth-service-1.0.0.jar

# 使用 Gradle
gradle bootRun

# 使用 Docker
docker-compose up -d
```

**验证服务**:

```bash
# 健康检查
curl http://localhost:8001/actuator/health

# 预期响应
{
  "status": "UP",
  "components": {
    "db": {
      "status": "UP"
    },
    "redis": {
      "status": "UP"
    }
  }
}
```

---

## 项目结构

```
auth-service/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── open436/
│   │   │           └── auth/
│   │   │               ├── AuthServiceApplication.java
│   │   │               ├── config/              # 配置类
│   │   │               │   ├── SecurityConfig.java
│   │   │               │   ├── JwtConfig.java
│   │   │               │   ├── RedisConfig.java
│   │   │               │   └── CorsConfig.java
│   │   │               ├── controller/          # 控制器
│   │   │               │   ├── AuthController.java
│   │   │               │   ├── UserController.java
│   │   │               │   └── PermissionController.java
│   │   │               ├── dto/                 # 数据传输对象
│   │   │               │   ├── LoginRequest.java
│   │   │               │   ├── LoginResponse.java
│   │   │               │   └── ApiResponse.java
│   │   │               ├── entity/              # 实体类
│   │   │               │   ├── UserAuth.java
│   │   │               │   ├── Role.java
│   │   │               │   ├── Permission.java
│   │   │               │   ├── UserRole.java
│   │   │               │   └── RolePermission.java
│   │   │               ├── repository/          # 数据访问层
│   │   │               │   ├── UserAuthRepository.java
│   │   │               │   ├── RoleRepository.java
│   │   │               │   └── PermissionRepository.java
│   │   │               ├── service/             # 业务逻辑层
│   │   │               │   ├── AuthService.java
│   │   │               │   ├── UserService.java
│   │   │               │   └── PermissionService.java
│   │   │               ├── security/            # 安全相关
│   │   │               │   ├── JwtTokenProvider.java
│   │   │               │   ├── JwtAuthenticationFilter.java
│   │   │               │   └── CustomUserDetailsService.java
│   │   │               ├── exception/           # 异常处理
│   │   │               │   ├── GlobalExceptionHandler.java
│   │   │               │   └── BusinessException.java
│   │   │               └── util/                # 工具类
│   │   │                   ├── PasswordUtil.java
│   │   │                   └── RedisUtil.java
│   │   └── resources/
│   │       ├── application.yml
│   │       ├── application-dev.yml
│   │       ├── application-prod.yml
│   │       └── db/
│   │           ├── migration/
│   │           │   └── V1__initial_schema.sql
│   │           └── seed/
│   │               └── V2__initial_data.sql
│   └── test/
│       └── java/
│           └── com/
│               └── open436/
│                   └── auth/
│                       ├── controller/
│                       └── service/
├── pom.xml
├── Dockerfile
├── docker-compose.yml
└── README.md
```

---

## 核心功能实现

### 用户登录

**文件**: `AuthController.java`

```java
package com.open436.auth.controller;

import com.open436.auth.dto.LoginRequest;
import com.open436.auth.dto.LoginResponse;
import com.open436.auth.dto.ApiResponse;
import com.open436.auth.service.AuthService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import javax.validation.Valid;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthService authService;

    @PostMapping("/login")
    public ResponseEntity<ApiResponse<LoginResponse>> login(
            @Valid @RequestBody LoginRequest request) {

        LoginResponse response = authService.login(request);

        return ResponseEntity.ok(
            ApiResponse.<LoginResponse>builder()
                .code(200)
                .message("登录成功")
                .data(response)
                .timestamp(System.currentTimeMillis())
                .build()
        );
    }

    @PostMapping("/logout")
    public ResponseEntity<ApiResponse<Void>> logout(
            @RequestHeader("Authorization") String token) {

        authService.logout(token);

        return ResponseEntity.ok(
            ApiResponse.<Void>builder()
                .code(200)
                .message("已成功退出登录")
                .timestamp(System.currentTimeMillis())
                .build()
        );
    }
}
```

**文件**: `AuthService.java`

```java
package com.open436.auth.service;

import com.open436.auth.dto.LoginRequest;
import com.open436.auth.dto.LoginResponse;
import com.open436.auth.entity.UserAuth;
import com.open436.auth.repository.UserAuthRepository;
import com.open436.auth.security.JwtTokenProvider;
import com.open436.auth.exception.BusinessException;
import lombok.RequiredArgsConstructor;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserAuthRepository userAuthRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtTokenProvider jwtTokenProvider;

    public LoginResponse login(LoginRequest request) {
        // 1. 查询用户
        UserAuth user = userAuthRepository
            .findByUsername(request.getUsername())
            .orElseThrow(() -> new BusinessException(40101001, "用户名或密码错误"));

        // 2. 检查账号状态
        if ("disabled".equals(user.getStatus())) {
            throw new BusinessException(40301001, "账号已被禁用，请联系管理员");
        }

        // 3. 验证密码
        if (!passwordEncoder.matches(request.getPassword(), user.getPasswordHash())) {
            throw new BusinessException(40101001, "用户名或密码错误");
        }

        // 4. 生成 Token
        String token = jwtTokenProvider.generateToken(
            user.getId(),
            user.getUsername(),
            user.getRole(),
            request.isRememberMe()
        );

        // 5. 更新最后登录时间
        user.setLastLoginAt(new java.util.Date());
        userAuthRepository.save(user);

        // 6. 返回结果
        return LoginResponse.builder()
            .token(token)
            .expiresIn(request.isRememberMe() ? 604800 : 7200)
            .user(LoginResponse.UserInfo.builder()
                .id(user.getId())
                .username(user.getUsername())
                .role(user.getRole())
                .status(user.getStatus())
                .build())
            .build();
    }

    public void logout(String token) {
        // 将 Token 加入黑名单
        jwtTokenProvider.addToBlacklist(token);
    }
}
```

### JWT 过滤器

**文件**: `JwtAuthenticationFilter.java`

```java
package com.open436.auth.security;

import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final CustomUserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(
            HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {

        try {
            // 1. 从 Header 获取 Token
            String token = getTokenFromRequest(request);

            if (token != null && jwtTokenProvider.validateToken(token)) {
                // 2. 从 Token 中获取用户名
                String username = jwtTokenProvider.getUsernameFromToken(token);

                // 3. 加载用户详情
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);

                // 4. 创建认证对象
                UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities()
                    );

                authentication.setDetails(
                    new WebAuthenticationDetailsSource().buildDetails(request)
                );

                // 5. 设置安全上下文
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            logger.error("Could not set user authentication in security context", ex);
        }

        filterChain.doFilter(request, response);
    }

    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");

        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }

        return null;
    }
}
```

---

## 测试

### 单元测试

```bash
# 运行所有测试
npm test

# 运行特定测试
npm test -- auth.test.js

# 测试覆盖率
npm run test:coverage
```

**测试示例**:

```javascript
// tests/unit/auth.test.js
const { login } = require("../../src/controllers/authController");
const { hashPassword } = require("../../src/utils/password");

describe("Auth Controller", () => {
  describe("login", () => {
    it("should return token on valid credentials", async () => {
      const req = {
        body: {
          username: "testuser",
          password: "password123",
        },
      };

      const res = {
        json: jest.fn(),
        status: jest.fn().mockReturnThis(),
      };

      await login(req, res);

      expect(res.json).toHaveBeenCalledWith(
        expect.objectContaining({
          code: 200,
          data: expect.objectContaining({
            token: expect.any(String),
          }),
        })
      );
    });
  });
});
```

### API 测试

```bash
# 使用 Postman 或 curl

# 登录
curl -X POST http://localhost:8001/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"admin123"}'

# 使用 Token 访问受保护接口
curl -X GET http://localhost:8001/api/auth/profile \
  -H "Authorization: Bearer eyJhbGci..."
```

---

## 部署

### Docker 部署

**Dockerfile**:

```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

EXPOSE 8001

CMD ["node", "src/app.js"]
```

**docker-compose.yml**:

```yaml
version: "3.8"

services:
  auth-service:
    build: .
    ports:
      - "8001:8001"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://open436:open436@postgres:5432/auth_db
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
    restart: unless-stopped

  postgres:
    image: postgres:14-alpine
    environment:
      POSTGRES_DB: auth_db
      POSTGRES_USER: open436
      POSTGRES_PASSWORD: open436
    volumes:
      - postgres-data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    volumes:
      - redis-data:/data

volumes:
  postgres-data:
  redis-data:
```

**启动**:

```bash
docker-compose up -d
```

---

## 监控与日志

### 日志配置

```javascript
// src/utils/logger.js
const winston = require("winston");

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: "logs/error.log", level: "error" }),
    new winston.transports.File({ filename: "logs/combined.log" }),
  ],
});

if (process.env.NODE_ENV !== "production") {
  logger.add(
    new winston.transports.Console({
      format: winston.format.simple(),
    })
  );
}

module.exports = logger;
```

### 健康检查

```javascript
// src/routes/health.js
router.get("/health", async (req, res) => {
  try {
    // 检查数据库连接
    await db.query("SELECT 1");

    // 检查 Redis 连接
    await redis.ping();

    res.json({
      status: "ok",
      service: "auth-service",
      version: "1.0.0",
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    res.status(503).json({
      status: "error",
      message: "Service unavailable",
    });
  }
});
```

---

## 常见问题

### Q1: 数据库连接失败

**错误**: `ECONNREFUSED`

**解决**:

1. 检查 PostgreSQL 是否运行
2. 验证数据库连接配置
3. 检查防火墙设置

### Q2: JWT Token 验证失败

**错误**: `Token 无效`

**解决**:

1. 检查 JWT_SECRET 是否一致
2. 验证 Token 格式（Bearer {token}）
3. 检查 Token 是否过期

### Q3: Redis 连接失败

**错误**: `Redis connection failed`

**解决**:

1. 检查 Redis 是否运行
2. 验证 Redis 连接配置
3. 检查 Redis 密码

---

## 相关文档

- [数据库设计](./01-数据库设计.md)
- [API 接口设计](./02-API接口设计.md)
- [JWT 实现方案](./03-JWT实现方案.md)
- [RBAC 权限模型](./04-RBAC权限模型.md)
- [安全方案](./05-安全方案.md)

---

**文档版本**: v1.0  
**创建日期**: 2025-10-23  
**最后更新**: 2025-10-23
